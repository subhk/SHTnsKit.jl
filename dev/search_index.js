var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation-Guide","page":"Installation","title":"Installation Guide","text":"<div style=\"background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">Installation</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Get SHTnsKit.jl up and running in your Julia environment</p>\n</div>\n\nThis guide provides detailed instructions for installing SHTnsKit.jl and its dependencies.","category":"section"},{"location":"installation/#Quick-Installation","page":"Installation","title":"Quick Installation","text":"using Pkg\nPkg.add(\"SHTnsKit\")","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/#System-Requirements","page":"Installation","title":"System Requirements","text":"Operating System: Linux, macOS, or Windows with WSL\nJulia: Version 1.9 or later (1.11+ recommended)\nMemory: At least 4GB RAM (16GB+ for large parallel problems)\nStorage: 2GB free space for dependencies (including MPI)\nMPI Library: OpenMPI or MPICH for parallel functionality","category":"section"},{"location":"installation/#Required-Dependencies","page":"Installation","title":"Required Dependencies","text":"SHTnsKit.jl is pure Julia and does not require an external C library. Core functionality uses Julia's standard libraries and FFTW.jl (installed automatically). Parallel features require additional packages.","category":"section"},{"location":"installation/#Installing-SHTnsKit.jl","page":"Installation","title":"Installing SHTnsKit.jl","text":"","category":"section"},{"location":"installation/#Basic-Installation-(Serial-Only)","page":"Installation","title":"Basic Installation (Serial Only)","text":"using Pkg\nPkg.add(\"SHTnsKit\")","category":"section"},{"location":"installation/#With-GPU-Support","page":"Installation","title":"With GPU Support","text":"using Pkg\nPkg.add([\"SHTnsKit\", \"CUDA\", \"GPUArrays\", \"KernelAbstractions\"])","category":"section"},{"location":"installation/#With-MPI-Support-(Parallel)","page":"Installation","title":"With MPI Support (Parallel)","text":"using Pkg\nPkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\"])","category":"section"},{"location":"installation/#Full-Installation-(GPU-Parallel-SIMD)","page":"Installation","title":"Full Installation (GPU + Parallel + SIMD)","text":"using Pkg\nPkg.add([\n    \"SHTnsKit\",\n    \"CUDA\", \"GPUArrays\", \"KernelAbstractions\",           # GPU\n    \"MPI\", \"PencilArrays\", \"PencilFFTs\",                 # Distributed\n    \"LoopVectorization\",                                  # SIMD optimization\n    \"ForwardDiff\", \"Zygote\"                              # Auto-differentiation\n])","category":"section"},{"location":"installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"For the latest features or contributing:\n\nusing Pkg\nPkg.add(url=\"https://github.com/username/SHTnsKit.jl.git\")","category":"section"},{"location":"installation/#Local-Development-Setup","page":"Installation","title":"Local Development Setup","text":"using Pkg\nPkg.develop(path=\"/path/to/SHTnsKit.jl\")","category":"section"},{"location":"installation/#GPU-Setup","page":"Installation","title":"GPU Setup","text":"","category":"section"},{"location":"installation/#Requirements","page":"Installation","title":"Requirements","text":"NVIDIA GPU with CUDA Compute Capability 5.0+ (Maxwell or newer)\nCUDA Toolkit (automatically installed via CUDA.jl)\n4GB+ GPU memory recommended","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add([\"CUDA\", \"GPUArrays\", \"KernelAbstractions\"])","category":"section"},{"location":"installation/#Verify-GPU-Installation","page":"Installation","title":"Verify GPU Installation","text":"using CUDA\n\nprintln(\"CUDA functional: \", CUDA.functional())\nprintln(\"CUDA version: \", CUDA.version())\nprintln(\"GPU: \", CUDA.name(CUDA.device()))\nprintln(\"Memory: \", CUDA.available_memory() / 1e9, \" GB available\")","category":"section"},{"location":"installation/#Test-GPU-Transforms","page":"Installation","title":"Test GPU Transforms","text":"using SHTnsKit, CUDA\n\n# Create configuration\ncfg = create_gauss_config(32, 34)\n\n# Create test data\nspatial = rand(cfg.nlat, cfg.nlon)\n\n# GPU transform\nAlm = gpu_analysis(cfg, spatial)\nrecovered = gpu_synthesis(cfg, Alm)\n\n# Verify\nerror = maximum(abs.(spatial - recovered))\nprintln(\"GPU roundtrip error: $error\")\nprintln(error < 1e-10 ? \"GPU SUCCESS!\" : \"Check GPU installation\")","category":"section"},{"location":"installation/#Troubleshooting-GPU","page":"Installation","title":"Troubleshooting GPU","text":"\"CUDA not available\"\n\n# Check CUDA installation\nusing CUDA\nprintln(CUDA.versioninfo())\n\n# Rebuild if needed\nusing Pkg\nPkg.build(\"CUDA\")\n\n\"Out of GPU memory\"\n\nUse gpu_analysis_safe() for automatic CPU fallback\nReduce problem size\nCall gpu_clear_cache!() to free memory\n\n","category":"section"},{"location":"installation/#Parallel-Computing-Setup","page":"Installation","title":"Parallel Computing Setup","text":"","category":"section"},{"location":"installation/#MPI-Installation","page":"Installation","title":"MPI Installation","text":"Linux (Ubuntu/Debian):\n\nsudo apt-get update\nsudo apt-get install libopenmpi-dev openmpi-bin\n\nmacOS:\n\nbrew install open-mpi\n\nConfigure Julia MPI:\n\nusing Pkg\nPkg.add(\"MPI\")\nPkg.build(\"MPI\")","category":"section"},{"location":"installation/#Verify-MPI-Installation","page":"Installation","title":"Verify MPI Installation","text":"using MPI\nMPI.Init()\nrank = Comm_rank(COMM_WORLD)\nsize = Comm_size(COMM_WORLD)\nprintln(\"Process $rank of $size\")\nMPI.Finalize()","category":"section"},{"location":"installation/#Optional-Performance-Packages","page":"Installation","title":"Optional Performance Packages","text":"using Pkg\nPkg.add([\"LoopVectorization\", \"BenchmarkTools\"])","category":"section"},{"location":"installation/#Verification","page":"Installation","title":"Verification","text":"","category":"section"},{"location":"installation/#Basic-Functionality-Test","page":"Installation","title":"Basic Functionality Test","text":"using SHTnsKit\n\n# Create simple configuration\ncfg = create_gauss_config(8, 8)\nprintln(\"lmax: \", get_lmax(cfg))\nprintln(\"nlat: \", cfg.nlat)  \nprintln(\"nphi: \", cfg.nlon)\n\n# Test basic transform\n# Create bandlimited test coefficients (avoids high-frequency errors)\nsh = zeros(cfg.nlm)\nsh[1] = 1.0\nif cfg.nlm > 3\n    sh[3] = 0.5\nend\nspat = synthesis(cfg, sh)\nprintln(\"Transform successful: \", size(spat))\n\ndestroy_config(cfg)\nprintln(\"SHTnsKit.jl installation verified!\")","category":"section"},{"location":"installation/#Parallel-Functionality-Test","page":"Installation","title":"Parallel Functionality Test","text":"Save this as test_mpi.jl and run with mpiexec -n 2 julia --project test_mpi.jl:\n\nusing MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\n# Create configuration\nlmax = 16\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed array\npen = Pencil((nlat, nlon), MPI.COMM_WORLD)\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test data (Y_2^0 pattern)\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    x = cfg.x[i_global]\n    for j in 1:length(ranges[2])\n        fθφ[i_local, j] = (3*x^2 - 1)/2\n    end\nend\n\n# Distributed roundtrip test\nAlm = SHTnsKit.dist_analysis(cfg, fθφ)\nfθφ_recovered = SHTnsKit.dist_synthesis(cfg, Alm; prototype_θφ=fθφ, real_output=true)\n\n# Verify accuracy\nmax_err = maximum(abs.(parent(fθφ_recovered) .- parent(fθφ)))\nglobal_max_err = MPI.Allreduce(max_err, MPI.MAX, MPI.COMM_WORLD)\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    println(\"Parallel roundtrip error: $global_max_err\")\n    println(global_max_err < 1e-10 ? \"SUCCESS!\" : \"FAILED\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()","category":"section"},{"location":"installation/#Extended-Verification","page":"Installation","title":"Extended Verification","text":"using SHTnsKit, Test, LinearAlgebra\n\n@testset \"Installation Verification\" begin\n    # Basic functionality\n    lmax = 16\n    cfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n    # Create bandlimited test pattern\n    spatial = zeros(cfg.nlat, cfg.nlon)\n    for i in 1:cfg.nlat\n        x = cfg.x[i]\n        spatial[i, :] .= (3*x^2 - 1)/2  # Y_2^0\n    end\n\n    # Roundtrip test\n    Alm = analysis(cfg, spatial)\n    recovered = synthesis(cfg, Alm)\n    @test norm(spatial - recovered) < 1e-12\n\n    # Memory management\n    destroy_config(cfg)\n    @test true  # No crash\nend","category":"section"},{"location":"installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"installation/#Common-Issues","page":"Installation","title":"Common Issues","text":"1. Array size mismatch:\n\nERROR: DimensionMismatch: spatial_data size (X, Y) must be (nlat, nlon)\n\nFix: Ensure size(Alm) == (cfg.lmax+1, cfg.mmax+1) and size(spatial) == (cfg.nlat, cfg.nlon).\n\n2. Memory issues:\n\nERROR: Out of memory\n\nSolutions:\n\nReduce problem size (lmax)\nIncrease system swap space\nReuse allocations with in‑place APIs (synthesis!, analysis!)","category":"section"},{"location":"installation/#Advanced-Debugging","page":"Installation","title":"Advanced Debugging","text":"Julia environment check:\n\nusing Libdl\nprintln(Libdl.dllist())  # List all loaded libraries","category":"section"},{"location":"installation/#Performance-Optimization","page":"Installation","title":"Performance Optimization","text":"","category":"section"},{"location":"installation/#System-Level-Optimizations","page":"Installation","title":"System-Level Optimizations","text":"Threading and memory tips:\n\n# Enable SHTnsKit internal threading and FFTW threads\nset_optimal_threads!()\nprintln((threads=get_threading(), fft_threads=get_fft_threads()))\n\n# Prevent oversubscription with BLAS/FFTW (optional)\nENV[\"OPENBLAS_NUM_THREADS\"] = \"1\"","category":"section"},{"location":"installation/#Julia-Specific","page":"Installation","title":"Julia-Specific","text":"Precompilation:\n\nusing PackageCompiler\ncreate_sysimage([:SHTnsKit]; sysimage_path=\"shtns_sysimage.so\")\n\nMemory:\n\njulia --heap-size-hint=8G script.jl","category":"section"},{"location":"installation/#Docker-Installation","page":"Installation","title":"Docker Installation","text":"For containerized environments:\n\nFROM julia:1.11\n\n# Install Julia packages\nRUN julia -e 'using Pkg; Pkg.add([\"SHTnsKit\"])'\n\n# Verify installation\nRUN julia -e 'using SHTnsKit; cfg = create_gauss_config(8,8); destroy_config(cfg)'","category":"section"},{"location":"installation/#Getting-Help","page":"Installation","title":"Getting Help","text":"Documentation: SHTnsKit.jl Docs\nIssues: GitHub Issues\nJulia Discourse: Julia Community","category":"section"},{"location":"norms/#Normalization-and-Condon–Shortley-Phase","page":"-","title":"Normalization and Condon–Shortley Phase","text":"SHTnsKit internally uses orthonormal spherical harmonics with the Condon–Shortley phase (CS) included. At the API level you can select:\n\nnorm = :orthonormal (default): same as internal.\nnorm = :fourpi: scales basis by sqrt(4π) relative to orthonormal.\nnorm = :schmidt: Schmidt semi-normalized, scales by sqrt(4π/(2l+1)).\ncs_phase = true/false: include or exclude the phase (-1)^m.\n\nTransforms convert your coefficients to/from the internal basis automatically. You can also use convert_alm_norm!(dest, src, cfg; to_internal) to map matrices explicitly between cfg’s requested normalization/phase and the internal one.\n\nFor packed real layouts (m ≥ 0) and complex packed layouts (both signs of m), point/latitude evaluation functions also honor norm and cs_phase per (l,m).","category":"section"},{"location":"parallel_installation/#Parallel-Computing-Installation-Guide","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"This comprehensive guide covers installing and configuring SHTnsKit.jl for high-performance parallel computing with MPI, PencilArrays, PencilFFTs, and SIMD optimizations.","category":"section"},{"location":"parallel_installation/#Overview","page":"Parallel Computing Installation Guide","title":"Overview","text":"SHTnsKit.jl supports multiple levels of performance optimization:\n\nSerial: Basic Julia threading and FFTW optimization\nSIMD: Enhanced vectorization with LoopVectorization.jl  \nMPI Parallel: Distributed computing with domain decomposition\nFull Stack: Combined MPI + SIMD + threading for maximum performance","category":"section"},{"location":"parallel_installation/#System-Requirements","page":"Parallel Computing Installation Guide","title":"System Requirements","text":"","category":"section"},{"location":"parallel_installation/#Package-Version-Compatibility","page":"Parallel Computing Installation Guide","title":"Package Version Compatibility","text":"SHTnsKit.jl's distributed extension requires specific minimum versions due to API changes:\n\nPackage Minimum Version Notes\nMPI.jl v0.20+ Uses Allgatherv! with VBuffer API\nPencilArrays.jl v0.19+ Uses range_local, size_local, get_comm API\nPencilFFTs.jl v0.15+ Compatible distributed FFT support\nJulia 1.9+ 1.11+ recommended for best performance\n\nImportant: Older versions of PencilArrays (< v0.19) used different APIs (communicator, globalindices) that are no longer supported.","category":"section"},{"location":"parallel_installation/#Minimum-Requirements","page":"Parallel Computing Installation Guide","title":"Minimum Requirements","text":"Operating System: Linux, macOS, or Windows with WSL\nJulia: Version 1.9+ (1.11+ recommended)\nMemory: 8GB RAM (32GB+ for large parallel problems)\nNetwork: Fast interconnect recommended for multi-node MPI","category":"section"},{"location":"parallel_installation/#Recommended-Hardware","page":"Parallel Computing Installation Guide","title":"Recommended Hardware","text":"CPU: Modern multi-core processor with AVX2/AVX512 support\nNetwork: InfiniBand or 10+ Gbps Ethernet for multi-node scaling\nStorage: NFS or parallel filesystem for multi-node jobs","category":"section"},{"location":"parallel_installation/#Installation-Steps","page":"Parallel Computing Installation Guide","title":"Installation Steps","text":"","category":"section"},{"location":"parallel_installation/#Step-1:-Basic-SHTnsKit-Installation","page":"Parallel Computing Installation Guide","title":"Step 1: Basic SHTnsKit Installation","text":"using Pkg\nPkg.add(\"SHTnsKit\")","category":"section"},{"location":"parallel_installation/#Step-2:-MPI-Setup","page":"Parallel Computing Installation Guide","title":"Step 2: MPI Setup","text":"Linux (Ubuntu/Debian):\n\n# Install MPI library\nsudo apt-get update\nsudo apt-get install libopenmpi-dev openmpi-bin\n\n# Optional: Install development tools\nsudo apt-get install build-essential gfortran\n\nLinux (CentOS/RHEL):\n\nsudo yum install openmpi-devel\n# or for newer systems:\nsudo dnf install openmpi-devel\n\n# Load MPI module\nmodule load mpi/openmpi-x86_64\n\nmacOS:\n\n# Install via Homebrew\nbrew install open-mpi\n\n# Optional: Install via MacPorts\n# sudo port install openmpi","category":"section"},{"location":"parallel_installation/#Step-3:-Julia-MPI-Configuration","page":"Parallel Computing Installation Guide","title":"Step 3: Julia MPI Configuration","text":"using Pkg\n\n# Install MPI.jl\nPkg.add(\"MPI\")\n\n# Build MPI with system library\nPkg.build(\"MPI\")\n\n# Verify installation\nusing MPI\nMPI.Init()\nprintln(\"MPI initialized successfully\")\nMPI.Finalize()","category":"section"},{"location":"parallel_installation/#Step-4:-Parallel-Computing-Packages","page":"Parallel Computing Installation Guide","title":"Step 4: Parallel Computing Packages","text":"using Pkg\n\n# Install complete parallel stack\nPkg.add([\n    \"MPI\",           # Message Passing Interface\n    \"PencilArrays\",  # Domain decomposition\n    \"PencilFFTs\",    # Distributed FFTs\n    \"LoopVectorization\"  # SIMD enhancements\n])\n\n# Optional performance packages\nPkg.add([\n    \"BenchmarkTools\",\n    \"Profile\",\n    \"ProfileView\"\n])","category":"section"},{"location":"parallel_installation/#Step-5:-Verification","page":"Parallel Computing Installation Guide","title":"Step 5: Verification","text":"Test MPI functionality:\n\n# Save as test_mpi.jl\nusing MPI\nMPI.Init()\n\ncomm = MPI.COMM_WORLD\nrank = Comm_rank(comm)\nsize = Comm_size(comm)\n\nprintln(\"Hello from process $rank of $size\")\n\nMPI.Finalize()\n\n# Run with multiple processes\nmpiexec -n 4 julia test_mpi.jl\n\nTest SHTnsKit parallel functionality:\n\nSave as test_parallel.jl:\n\nusing MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nnprocs = MPI.Comm_size(MPI.COMM_WORLD)\n\nif rank == 0\n    println(\"Testing with $nprocs MPI processes\")\nend\n\n# Create configuration\nlmax = 16\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed array\npen = Pencil((nlat, nlon), MPI.COMM_WORLD)\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test data (Y_2^0)\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    x = cfg.x[i_global]\n    for j in 1:length(ranges[2])\n        fθφ[i_local, j] = (3*x^2 - 1)/2\n    end\nend\n\n# Test distributed transforms\nAlm = SHTnsKit.dist_analysis(cfg, fθφ)\nfθφ_out = SHTnsKit.dist_synthesis(cfg, Alm; prototype_θφ=fθφ, real_output=true)\n\n# Verify accuracy\nmax_err = maximum(abs.(parent(fθφ_out) .- parent(fθφ)))\nglobal_max_err = MPI.Allreduce(max_err, MPI.MAX, MPI.COMM_WORLD)\n\nif rank == 0\n    println(\"Roundtrip error: $global_max_err\")\n    println(global_max_err < 1e-10 ? \"SUCCESS!\" : \"FAILED\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()\n\n# Test parallel mode\nmpiexec -n 2 julia --project test_parallel.jl\n\nRun the built-in parallel testset (includes PencilArrays/PencilFFTs):\n\nSHTNSKIT_RUN_MPI_TESTS=1 JULIA_NUM_THREADS=1 \\\n    mpiexec -n 2 julia --project -e 'using Pkg; Pkg.test()'\n\nThis exercises distributed analysis/synthesis, vector/QST transforms, rotations, and diagnostics across ranks using PencilArrays and PencilFFTs.","category":"section"},{"location":"parallel_installation/#Advanced-Configuration","page":"Parallel Computing Installation Guide","title":"Advanced Configuration","text":"","category":"section"},{"location":"parallel_installation/#Environment-Variables","page":"Parallel Computing Installation Guide","title":"Environment Variables","text":"MPI tuning:\n\n# Reduce MPI warnings\nexport OMPI_MCA_mpi_warn_on_fork=0\n\n# Network interface selection\nexport OMPI_MCA_btl_tcp_if_include=eth0\n\n# Memory pinning\nexport OMPI_MCA_mpi_leave_pinned=1\n\n# Collective algorithm selection\nexport OMPI_MCA_coll_hcoll_enable=1\n\nJulia optimization:\n\n# Threading\nexport JULIA_NUM_THREADS=8\nexport OPENBLAS_NUM_THREADS=1\nexport FFTW_NUM_THREADS=4\n\n# Memory\nexport JULIA_GC_ALLOC_POOL_GROW_THRESHOLD=0.1","category":"section"},{"location":"parallel_installation/#Performance-Tuning","page":"Parallel Computing Installation Guide","title":"Performance Tuning","text":"Process binding (recommended):\n\n# Bind to cores\nmpiexec --bind-to core -n 8 julia script.jl\n\n# NUMA-aware binding\nmpiexec --map-by socket --bind-to core -n 16 julia script.jl\n\nLarge problem optimization:\n\n# Increase memory limits\nulimit -s unlimited\nulimit -v unlimited\n\n# Run with large heap\nmpiexec -n 8 julia --heap-size-hint=32G script.jl","category":"section"},{"location":"parallel_installation/#Container-Deployment","page":"Parallel Computing Installation Guide","title":"Container Deployment","text":"","category":"section"},{"location":"parallel_installation/#Docker","page":"Parallel Computing Installation Guide","title":"Docker","text":"Basic parallel container:\n\nFROM julia:1.11\n\n# Install MPI\nRUN apt-get update && \\\n    apt-get install -y libopenmpi-dev openmpi-bin && \\\n    rm -rf /var/lib/apt/lists/*\n\n# Install Julia packages\nRUN julia -e 'using Pkg; \\\n              Pkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\", \"LoopVectorization\"]); \\\n              using MPI; \\\n              MPI.install_mpiexecjl()'\n\n# Precompile\nRUN julia -e 'using SHTnsKit, MPI, PencilArrays, PencilFFTs'\n\nWORKDIR /app\nCOPY . .\n\n# Run with: docker run --rm -it image mpiexecjl -n 4 julia script.jl","category":"section"},{"location":"parallel_installation/#Singularity/Apptainer","page":"Parallel Computing Installation Guide","title":"Singularity/Apptainer","text":"HPC-ready container:\n\nBootstrap: docker\nFrom: julia:1.11\n\n%post\n    apt-get update\n    apt-get install -y libopenmpi-dev openmpi-bin\n    \n    julia -e 'using Pkg; \n              Pkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\", \"LoopVectorization\"]); \n              using MPI; MPI.install_mpiexecjl()'\n    \n    julia -e 'using SHTnsKit, MPI, PencilArrays, PencilFFTs'\n\n%runscript\n    exec julia \"$@\"\n\n# Build and run\nsingularity build shtns.sif shtns.def\nmpirun -n 8 singularity exec shtns.sif julia script.jl","category":"section"},{"location":"parallel_installation/#HPC-Cluster-Setup","page":"Parallel Computing Installation Guide","title":"HPC Cluster Setup","text":"","category":"section"},{"location":"parallel_installation/#SLURM-Job-Script","page":"Parallel Computing Installation Guide","title":"SLURM Job Script","text":"#!/bin/bash\n#SBATCH --job-name=shtns_parallel\n#SBATCH --nodes=2\n#SBATCH --ntasks-per-node=16\n#SBATCH --time=01:00:00\n#SBATCH --partition=compute\n\n# Load modules\nmodule load julia/1.11\nmodule load openmpi/4.1.0\n\n# Set environment\nexport JULIA_NUM_THREADS=2\nexport OPENBLAS_NUM_THREADS=1\n\n# Run parallel job\nmpirun julia --project=. parallel_example.jl --benchmark","category":"section"},{"location":"parallel_installation/#PBS/Torque-Script","page":"Parallel Computing Installation Guide","title":"PBS/Torque Script","text":"#!/bin/bash\n#PBS -N shtns_job\n#PBS -l nodes=4:ppn=8\n#PBS -l walltime=02:00:00\n#PBS -q normal\n\ncd $PBS_O_WORKDIR\n\n# Load modules\nmodule load julia/1.11\nmodule load openmpi/3.1.4\n\n# Run job\nmpirun -np 32 julia --project=. examples/parallel_example.jl","category":"section"},{"location":"parallel_installation/#Troubleshooting","page":"Parallel Computing Installation Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"parallel_installation/#Common-Issues","page":"Parallel Computing Installation Guide","title":"Common Issues","text":"1. MPI library mismatch:\n\nERROR: MPI library not found\n\nSolution:\n\n# Force MPI.jl to use system MPI\nENV[\"JULIA_MPI_BINARY\"] = \"system\"\nusing Pkg; Pkg.build(\"MPI\")\n\n2. PencilArrays compilation errors:\n\nERROR: LoadError: FFTW not found\n\nSolution:\n\n# Install FFTW explicitly\nusing Pkg\nPkg.add(\"FFTW\")\nPkg.build(\"FFTW\")\nPkg.build(\"PencilFFTs\")\n\n3. Process binding warnings:\n\nWARNING: A process refused to die!\n\nSolution:\n\n# Use proper MPI cleanup\nexport OMPI_MCA_orte_tmpdir_base=/tmp\nmpiexec --mca orte_base_help_aggregate 0 -n 4 julia script.jl\n\n4. PencilArrays API errors (version mismatch):\n\nERROR: MethodError: no method matching communicator(::Pencil{...})\nERROR: MethodError: no method matching globalindices(::PencilArray{...})\n\nCause: You have an older version of PencilArrays (< v0.19) that uses different API names.\n\nSolution:\n\n# Update to PencilArrays v0.19+\nusing Pkg\nPkg.update(\"PencilArrays\")\nPkg.update(\"PencilFFTs\")\n\n# Verify version\nPkg.status(\"PencilArrays\")  # Should show v0.19+\n\nThe new PencilArrays v0.19+ API uses:\n\nget_comm(pen) instead of communicator(pen)\nrange_local(pen) instead of globalindices(arr, dim)\nsize_local(pen) instead of other size functions\n\n5. Precompilation cache conflicts with MPI:\n\nERROR: Permission denied @ mkdir_pid_file\nERROR: InexactError: ... (random memory errors)\n\nCause: Multiple MPI processes trying to write to the same precompilation cache simultaneously.\n\nSolution:\n\n# Use a fresh depot for MPI runs\nJULIA_DEPOT_PATH=/tmp/fresh_depot:$HOME/.julia mpiexec -n 4 julia script.jl\n\n# Or precompile in serial first\njulia --project -e 'using SHTnsKit, MPI, PencilArrays, PencilFFTs'\nmpiexec -n 4 julia --project script.jl","category":"section"},{"location":"parallel_installation/#Performance-Issues","page":"Parallel Computing Installation Guide","title":"Performance Issues","text":"Slow initialization:\n\nPrecompile packages: julia -e 'using SHTnsKit, MPI, PencilArrays, PencilFFTs'\nUse system image: julia --sysimage=shtns_parallel.so script.jl\n\nPoor scaling:\n\nCheck network bandwidth: iperf3 between nodes\nVerify process binding: numactl --show\nMonitor MPI communication: mpiP profiling\n\nMemory errors:\n\nIncrease system limits: ulimit -v unlimited\nUse memory-efficient transforms: memory_efficient_parallel_transform!()\nProcess data in chunks for very large problems","category":"section"},{"location":"parallel_installation/#Validation-and-Testing","page":"Parallel Computing Installation Guide","title":"Validation and Testing","text":"","category":"section"},{"location":"parallel_installation/#Comprehensive-Test-Script","page":"Parallel Computing Installation Guide","title":"Comprehensive Test Script","text":"Save as test_complete_setup.jl:\n\nusing Test\nusing SHTnsKit\nusing LinearAlgebra\n\n@testset \"Complete Setup Verification\" begin\n    # Test basic functionality\n    lmax = 16\n    cfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n    @test cfg.nlm > 0\n\n    # Test parallel packages availability\n    @testset \"Package Loading\" begin\n        @test_nowarn using MPI\n        @test_nowarn using PencilArrays\n        @test_nowarn using PencilFFTs\n    end\n\n    # Test basic transforms\n    @testset \"Transform Accuracy\" begin\n        spatial = zeros(cfg.nlat, cfg.nlon)\n        for i in 1:cfg.nlat\n            x = cfg.x[i]\n            spatial[i, :] .= (3*x^2 - 1)/2  # Y_2^0\n        end\n\n        Alm = analysis(cfg, spatial)\n        recovered = synthesis(cfg, Alm)\n        @test norm(spatial - recovered) < 1e-12\n    end\n\n    destroy_config(cfg)\nend\n\nprintln(\"All tests passed!\")\n\n# Run validation\njulia --project test_complete_setup.jl","category":"section"},{"location":"parallel_installation/#Performance-Benchmarking","page":"Parallel Computing Installation Guide","title":"Performance Benchmarking","text":"# benchmark_setup.jl\nusing SHTnsKit, BenchmarkTools\n\nfunction run_benchmarks()\n    println(\"SHTnsKit.jl Performance Benchmark\")\n    println(\"=\" ^ 50)\n\n    # Test different problem sizes\n    for lmax in [16, 32, 64]\n        nlat = lmax + 2\n        nlon = 2*lmax + 1\n        cfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n        # Create test data\n        spatial = zeros(cfg.nlat, cfg.nlon)\n        for i in 1:cfg.nlat\n            x = cfg.x[i]\n            spatial[i, :] .= (3*x^2 - 1)/2\n        end\n\n        println(\"\\nlmax = $lmax ($(cfg.nlm) coefficients, $(nlat)×$(nlon) grid)\")\n\n        # Serial transform benchmarks\n        t_analysis = @belapsed analysis($cfg, $spatial)\n        Alm = analysis(cfg, spatial)\n        t_synthesis = @belapsed synthesis($cfg, $Alm)\n\n        println(\"  Analysis: $(t_analysis*1000) ms\")\n        println(\"  Synthesis: $(t_synthesis*1000) ms\")\n\n        destroy_config(cfg)\n    end\nend\n\nrun_benchmarks()\n\nYour parallel SHTnsKit.jl installation is now complete and optimized for high-performance computing!","category":"section"},{"location":"performance/#Performance-Guide","page":"Performance Guide","title":"Performance Guide","text":"<div style=\"background: linear-gradient(135deg, #dc2626 0%, #f97316 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">Optimize Your Transforms</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Threading, memory management, and algorithm-level optimizations</p>\n</div>\n\nThis guide provides comprehensive information on optimizing SHTnsKit.jl performance for various computational scenarios, including serial, parallel (MPI), and SIMD optimizations.\n\ntip: Quick Wins\nPre-allocate arrays and reuse buffers\nUse in-place operations (analysis!, synthesis!)\nSet FFTW threads appropriately\nFor lmax > 64, consider GPU acceleration","category":"section"},{"location":"performance/#Understanding-Performance-Characteristics","page":"Performance Guide","title":"Understanding Performance Characteristics","text":"","category":"section"},{"location":"performance/#Transform-Complexity","page":"Performance Guide","title":"Transform Complexity","text":"Spherical harmonic transforms have the following computational characteristics:\n\nPractical implementations: approximately O(L³) in maximum degree L\nMemory: O(L²) for spectral coefficients and spatial grid","category":"section"},{"location":"performance/#Performance-Scaling","page":"Performance Guide","title":"Performance Scaling","text":"using SHTnsKit\nusing BenchmarkTools\n\nfunction benchmark_transforms(lmax_values)\n    results = []\n\n    for lmax in lmax_values\n        nlat = lmax + 2\n        nlon = 2*lmax + 1\n        cfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n        # Create bandlimited test data\n        spatial = zeros(cfg.nlat, cfg.nlon)\n        for i in 1:cfg.nlat\n            x = cfg.x[i]\n            spatial[i, :] .= (3*x^2 - 1)/2  # Y_2^0\n        end\n\n        # Benchmark forward transform (synthesis)\n        Alm = analysis(cfg, spatial)\n        forward_time = @belapsed synthesis($cfg, $Alm)\n\n        # Benchmark backward transform (analysis)\n        backward_time = @belapsed analysis($cfg, $spatial)\n\n        push!(results, (lmax=lmax, forward=forward_time, backward=backward_time))\n        destroy_config(cfg)\n    end\n\n    return results\nend\n\n# Test scaling\nlmax_range = [16, 32, 64, 128, 256]\nresults = benchmark_transforms(lmax_range)\n\nfor r in results\n    println(\"lmax=$(r.lmax): forward=$(r.forward)s, backward=$(r.backward)s\")\nend","category":"section"},{"location":"performance/#Parallel-Computing-Performance","page":"Performance Guide","title":"Parallel Computing Performance","text":"","category":"section"},{"location":"performance/#MPI-Parallelization","page":"Performance Guide","title":"MPI Parallelization","text":"For large problems, MPI parallelization provides significant speedup:\n\nusing MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\n# Configuration\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed array\npen = Pencil((nlat, nlon), MPI.COMM_WORLD)\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test data\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    x = cfg.x[i_global]\n    for j in 1:length(ranges[2])\n        fθφ[i_local, j] = (3*x^2 - 1)/2\n    end\nend\n\n# Benchmark distributed transforms\nfunction benchmark_parallel_performance()\n    rank = MPI.Comm_rank(MPI.COMM_WORLD)\n    nprocs = MPI.Comm_size(MPI.COMM_WORLD)\n\n    # Warm up\n    Alm = SHTnsKit.dist_analysis(cfg, fθφ)\n\n    # Benchmark\n    time_analysis = @elapsed begin\n        for i in 1:50\n            SHTnsKit.dist_analysis(cfg, fθφ)\n        end\n    end\n\n    if rank == 0\n        println(\"Parallel performance ($nprocs processes):\")\n        println(\"  Analysis: $(time_analysis/50*1000) ms per transform\")\n    end\nend\n\nbenchmark_parallel_performance()\ndestroy_config(cfg)\nMPI.Finalize()","category":"section"},{"location":"performance/#Threading-Optimization","page":"Performance Guide","title":"Threading Optimization","text":"","category":"section"},{"location":"performance/#Julia-Threads-and-FFTW","page":"Performance Guide","title":"Julia Threads and FFTW","text":"SHTnsKit uses Julia Threads.@threads and FFTW's internal threads. Configure them for best results:\n\nusing SHTnsKit\nusing FFTW\n\n# Check system capabilities\nprintln(\"System threads: \", Sys.CPU_THREADS)\nprintln(\"Julia threads: \", Threads.nthreads())\n\n# Manual FFTW thread control\nfunction benchmark_threading(lmax=64)\n    nlat = lmax + 2\n    nlon = 2*lmax + 1\n    cfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n    # Create bandlimited test data\n    spatial = zeros(cfg.nlat, cfg.nlon)\n    for i in 1:cfg.nlat\n        x = cfg.x[i]\n        spatial[i, :] .= (3*x^2 - 1)/2\n    end\n\n    thread_counts = [1, 2, 4, min(8, Sys.CPU_THREADS)]\n    times = Float64[]\n\n    for nthreads in thread_counts\n        FFTW.set_num_threads(nthreads)\n        time = @elapsed begin\n            for i in 1:10\n                analysis(cfg, spatial)\n            end\n        end\n        push!(times, time)\n        println(\"$nthreads FFTW threads: $(time/10*1000) ms per transform\")\n    end\n\n    destroy_config(cfg)\nend\n\nbenchmark_threading()","category":"section"},{"location":"performance/#Avoiding-Oversubscription","page":"Performance Guide","title":"Avoiding Oversubscription","text":"# Prevent thread oversubscription with other libraries\nENV[\"OPENBLAS_NUM_THREADS\"] = \"1\"\nENV[\"MKL_NUM_THREADS\"] = \"1\"\nENV[\"FFTW_NUM_THREADS\"] = \"1\"\n\n# Keep FFTW threads modest to avoid contention\nset_fft_threads(min(Sys.CPU_THREADS ÷ 2, 8))","category":"section"},{"location":"performance/#Memory-Optimization","page":"Performance Guide","title":"Memory Optimization","text":"","category":"section"},{"location":"performance/#Pre-allocation-Strategies","page":"Performance Guide","title":"Pre-allocation Strategies","text":"using SHTnsKit\n\nlmax = 64\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n# Method 1: Pre-allocate buffers for in-place operations\nAlm_buffer = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nspatial_buffer = zeros(cfg.nlat, cfg.nlon)\nfft_scratch = scratch_fft(cfg)\n\nfunction process_many_fields_optimized(cfg, n_fields)\n    results = Float64[]\n\n    for i in 1:n_fields\n        # Generate field data\n        for j in 1:cfg.nlat\n            x = cfg.x[j]\n            spatial_buffer[j, :] .= x^2 + 0.1*sin(i)\n        end\n\n        # In-place transform (reuses fft_scratch)\n        analysis!(cfg, Alm_buffer, spatial_buffer; fft_scratch=fft_scratch)\n\n        # Process result\n        energy = sum(abs2, Alm_buffer)\n        push!(results, energy)\n    end\n\n    return results\nend\n\n# vs Method 2: Allocate every time (slower)\nfunction process_many_fields_naive(cfg, n_fields)\n    results = Float64[]\n\n    for i in 1:n_fields\n        spatial = zeros(cfg.nlat, cfg.nlon)\n        for j in 1:cfg.nlat\n            x = cfg.x[j]\n            spatial[j, :] .= x^2 + 0.1*sin(i)\n        end\n        Alm = analysis(cfg, spatial)  # Allocates new array\n        energy = sum(abs2, Alm)\n        push!(results, energy)\n    end\n\n    return results\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"performance/#Memory-Layout-Optimization","page":"Performance Guide","title":"Memory Layout Optimization","text":"# For batch processing, consider array-of-arrays vs matrix layout\nusing SHTnsKit\n\nlmax = 32\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\nn_fields = 100\n\n# Layout 1: Array of matrices (better for random access)\nspectral_data_aoa = [zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1) for _ in 1:n_fields]\nfor arr in spectral_data_aoa\n    arr[1,1] = 1.0\n    arr[3,1] = 0.5\nend\n\n# Process with array of arrays\n@time begin\n    for i in 1:n_fields\n        spatial = synthesis(cfg, spectral_data_aoa[i])\n    end\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"performance/#Large-Problem-Memory-Management","page":"Performance Guide","title":"Large Problem Memory Management","text":"using SHTnsKit\nusing Statistics\n\nfunction process_large_dataset(lmax=256, n_fields=1000)\n    nlat = lmax + 2\n    nlon = 2*lmax + 1\n    cfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n    # For very large problems, process in chunks\n    chunk_size = 100\n    n_chunks = div(n_fields, chunk_size)\n\n    results = Float64[]\n\n    # Pre-allocate buffers to reuse\n    Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n\n    for chunk in 1:n_chunks\n        chunk_results = Float64[]\n\n        for i in 1:chunk_size\n            # Modify coefficients in place\n            fill!(Alm, 0.0)\n            Alm[1,1] = 1.0 + 0.01*i\n            Alm[3,1] = 0.5\n\n            spatial = synthesis(cfg, Alm)\n            push!(chunk_results, mean(spatial))\n        end\n\n        append!(results, chunk_results)\n        GC.gc()  # Force garbage collection between chunks\n    end\n\n    destroy_config(cfg)\n    return results\nend","category":"section"},{"location":"performance/#GPU-Acceleration","page":"Performance Guide","title":"GPU Acceleration","text":"For GPU-accelerated transforms, see the dedicated GPU Guide. GPU acceleration provides 10-30× speedup for large problems (lmax > 64).\n\nusing SHTnsKit, CUDA\n\ncfg = create_gauss_config(128, 130)\nspatial = rand(cfg.nlat, cfg.nlon)\n\n# GPU transforms\nAlm = gpu_analysis(cfg, spatial)\nrecovered = gpu_synthesis(cfg, Alm)\n\ntip: When to Use GPU\nGPU acceleration is most beneficial for lmax ≥ 64. For smaller problems, CPU is often faster due to data transfer overhead.","category":"section"},{"location":"performance/#Algorithm-Specific-Optimizations","page":"Performance Guide","title":"Algorithm-Specific Optimizations","text":"","category":"section"},{"location":"performance/#Transform-Direction-Optimization","page":"Performance Guide","title":"Transform Direction Optimization","text":"using SHTnsKit\n\nlmax = 64\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n# Forward transforms (synthesis) are generally faster than backward (analysis)\n# Plan your algorithm to minimize analysis operations\n\nfunction optimize_transform_direction(cfg)\n    # Create test coefficients\n    Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Alm[1,1] = 1.0\n    Alm[3,1] = 0.5\n\n    # Create test spatial data\n    spatial = zeros(cfg.nlat, cfg.nlon)\n    for i in 1:cfg.nlat\n        x = cfg.x[i]\n        spatial[i, :] .= (3*x^2 - 1)/2\n    end\n\n    # Forward transform timing (synthesis)\n    forward_time = @elapsed begin\n        for i in 1:100\n            synthesis(cfg, Alm)\n        end\n    end\n\n    # Backward transform timing (analysis)\n    backward_time = @elapsed begin\n        for i in 1:100\n            analysis(cfg, spatial)\n        end\n    end\n\n    println(\"Synthesis: $(forward_time/100*1000) ms\")\n    println(\"Analysis: $(backward_time/100*1000) ms\")\n    println(\"Ratio: $(backward_time/forward_time)\")\nend\n\noptimize_transform_direction(cfg)\ndestroy_config(cfg)","category":"section"},{"location":"performance/#Grid-Type-Selection","page":"Performance Guide","title":"Grid Type Selection","text":"using SHTnsKit\n\nfunction compare_grid_types(lmax=32)\n    nlat = lmax + 2\n    nlon = 2*lmax + 1\n\n    # Gauss grids: optimal for accuracy\n    cfg_gauss = create_gauss_config(lmax, nlat; nlon=nlon)\n\n    # Regular grids: uniform spacing\n    cfg_regular = create_regular_config(lmax, nlat; nlon=nlon)\n\n    println(\"Grid Comparison (lmax=$lmax):\")\n    println(\"Gauss: $(cfg_gauss.nlat) × $(cfg_gauss.nlon) points\")\n    println(\"Regular: $(cfg_regular.nlat) × $(cfg_regular.nlon) points\")\n\n    # Create test coefficients\n    Alm = zeros(ComplexF64, cfg_gauss.lmax+1, cfg_gauss.mmax+1)\n    Alm[1,1] = 1.0\n    Alm[3,1] = 0.5\n\n    gauss_time = @elapsed begin\n        for i in 1:50\n            synthesis(cfg_gauss, Alm)\n        end\n    end\n\n    regular_time = @elapsed begin\n        for i in 1:50\n            synthesis(cfg_regular, Alm)\n        end\n    end\n\n    println(\"Gauss time: $(gauss_time/50*1000) ms\")\n    println(\"Regular time: $(regular_time/50*1000) ms\")\n\n    destroy_config(cfg_gauss)\n    destroy_config(cfg_regular)\nend\n\ncompare_grid_types()","category":"section"},{"location":"performance/#Vector-Field-Performance","page":"Performance Guide","title":"Vector Field Performance","text":"using SHTnsKit\n\nlmax = 48\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n# Vector transforms are more expensive than scalar\nfunction benchmark_vector_vs_scalar(cfg)\n    # Scalar coefficients\n    Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Alm[1,1] = 1.0\n    Alm[3,1] = 0.5\n\n    # Scalar spatial field\n    spatial_scalar = zeros(cfg.nlat, cfg.nlon)\n    for i in 1:cfg.nlat\n        x = cfg.x[i]\n        spatial_scalar[i, :] .= (3*x^2 - 1)/2\n    end\n\n    # Vector coefficients\n    Slm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Tlm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Slm[2,1] = 1.0\n    Tlm[3,2] = 0.5\n\n    # Vector spatial fields\n    Vθ, Vφ = SHsphtor_to_spat(cfg, Slm, Tlm)\n\n    # Scalar benchmarks\n    scalar_synth = @elapsed begin\n        for i in 1:20\n            synthesis(cfg, Alm)\n        end\n    end\n\n    scalar_analysis = @elapsed begin\n        for i in 1:20\n            analysis(cfg, spatial_scalar)\n        end\n    end\n\n    # Vector benchmarks\n    vector_synth = @elapsed begin\n        for i in 1:20\n            SHsphtor_to_spat(cfg, Slm, Tlm)\n        end\n    end\n\n    vector_analysis = @elapsed begin\n        for i in 1:20\n            spat_to_SHsphtor(cfg, Vθ, Vφ)\n        end\n    end\n\n    println(\"Transform Performance Comparison:\")\n    println(\"Scalar synthesis: $(scalar_synth/20*1000) ms\")\n    println(\"Vector synthesis: $(vector_synth/20*1000) ms\")\n    println(\"Scalar analysis: $(scalar_analysis/20*1000) ms\")\n    println(\"Vector analysis: $(vector_analysis/20*1000) ms\")\nend\n\nbenchmark_vector_vs_scalar(cfg)\ndestroy_config(cfg)\n\n<!– Distributed/MPI performance guidance omitted for this package. –>","category":"section"},{"location":"performance/#Performance-Monitoring-and-Profiling","page":"Performance Guide","title":"Performance Monitoring and Profiling","text":"","category":"section"},{"location":"performance/#Built-in-Benchmarking","page":"Performance Guide","title":"Built-in Benchmarking","text":"using SHTnsKit\nusing Profile\nusing BenchmarkTools\nusing Statistics\n\nlmax = 64\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\nfunction profile_transforms(cfg)\n    # Create test coefficients\n    Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Alm[1,1] = 1.0\n    Alm[3,1] = 0.5\n\n    # Detailed benchmarking\n    forward_bench = @benchmark synthesis($cfg, $Alm)\n    println(\"Forward transform statistics:\")\n    println(\"  Median: $(median(forward_bench.times)/1e6) ms\")\n    println(\"  Mean: $(mean(forward_bench.times)/1e6) ms\")\n\n    # Memory allocation tracking\n    spatial = synthesis(cfg, Alm)\n    backward_bench = @benchmark analysis($cfg, $spatial)\n\n    println(\"Backward transform statistics:\")\n    println(\"  Median: $(median(backward_bench.times)/1e6) ms\")\n    println(\"  Allocations: $(backward_bench.memory) bytes\")\nend\n\nprofile_transforms(cfg)\n\n# Julia profiling\nfunction profile_detailed(cfg)\n    Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Alm[1,1] = 1.0\n\n    Profile.clear()\n    @profile begin\n        for i in 1:100\n            synthesis(cfg, Alm)\n        end\n    end\n\n    Profile.print()\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"performance/#Custom-Performance-Metrics","page":"Performance Guide","title":"Custom Performance Metrics","text":"using SHTnsKit\nusing Statistics\n\nfunction performance_report(lmax, n_runs=100)\n    nlat = lmax + 2\n    nlon = 2*lmax + 1\n    cfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n    # Create test coefficients\n    Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Alm[1,1] = 1.0\n    Alm[3,1] = 0.5\n\n    # Warm up\n    for i in 1:5\n        synthesis(cfg, Alm)\n    end\n\n    # Collect metrics\n    times = Float64[]\n\n    for i in 1:n_runs\n        time = @elapsed synthesis(cfg, Alm)\n        push!(times, time)\n    end\n\n    # Statistics\n    mean_time = mean(times)\n    std_time = std(times)\n    min_time = minimum(times)\n    max_time = maximum(times)\n\n    # Compute derived metrics\n    operations_per_sec = 1.0 / mean_time\n    points_per_sec = (cfg.nlat * cfg.nlon) / mean_time\n\n    println(\"Performance Report (lmax=$lmax, $n_runs runs):\")\n    println(\"  Mean time: $(mean_time*1000) ms (±$(std_time*1000) ms)\")\n    println(\"  Min/Max: $(min_time*1000) ms / $(max_time*1000) ms\")\n    println(\"  Transforms/sec: $(round(operations_per_sec, digits=1))\")\n    println(\"  Points/sec: $(round(points_per_sec/1e6, digits=2)) M\")\n\n    destroy_config(cfg)\nend\n\nperformance_report(32)","category":"section"},{"location":"performance/#Optimization-Checklist","page":"Performance Guide","title":"Optimization Checklist","text":"","category":"section"},{"location":"performance/#Before-Optimization","page":"Performance Guide","title":"Before Optimization","text":"[ ] Profile your code to identify bottlenecks\n[ ] Understand your problem's computational characteristics\n[ ] Measure baseline performance","category":"section"},{"location":"performance/#Threading-Optimization-2","page":"Performance Guide","title":"Threading Optimization","text":"[ ] Set OMP_NUM_THREADS appropriately\n[ ] Use set_optimal_threads() for automatic tuning\n[ ] Disable threading in other libraries (BLAS, FFTW)\n[ ] Consider NUMA topology for large systems","category":"section"},{"location":"performance/#Memory-Optimization-2","page":"Performance Guide","title":"Memory Optimization","text":"[ ] Pre-allocate buffers for repeated operations\n[ ] Use in-place transforms when possible\n[ ] Process data in chunks for large datasets\n[ ] Monitor memory usage and fragmentation","category":"section"},{"location":"performance/#Algorithm-Optimization","page":"Performance Guide","title":"Algorithm Optimization","text":"[ ] Minimize backward transforms (analysis)\n[ ] Choose appropriate grid type (Gauss vs regular)\n[ ] Batch operations when possible\n[ ] Cache frequently used configurations\n\n<!– GPU optimization checklist removed –>\n\n[ ] Use appropriate batch sizes","category":"section"},{"location":"performance/#System-Level-Optimization","page":"Performance Guide","title":"System-Level Optimization","text":"[ ] Use high-performance BLAS library\n[ ] Enable CPU optimizations (AVX, etc.)\n[ ] Consider process/thread affinity\n[ ] Monitor system resource utilization","category":"section"},{"location":"performance/#Performance-Validation","page":"Performance Guide","title":"Performance Validation","text":"[ ] Compare with baseline measurements\n[ ] Verify numerical accuracy after optimization\n[ ] Test with realistic problem sizes\n[ ] Document performance characteristics","category":"section"},{"location":"performance/#Common-Performance-Pitfalls","page":"Performance Guide","title":"Common Performance Pitfalls","text":"Thread Oversubscription: Too many threads can hurt performance\nMemory Allocation: Repeated allocation in inner loops\nWrong Grid Type: Regular grids when Gauss would suffice\nUnnecessary Transforms: Computing both directions when only one needed\nPerformance pitfalls: array allocations in hot loops, oversubscription of threads\n\nFollowing these guidelines will help you achieve optimal performance for your specific SHTnsKit.jl applications.","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"<div style=\"background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">API Reference</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Complete function and type documentation</p>\n</div>\n\nComplete reference for all SHTnsKit.jl functions and types.","category":"section"},{"location":"api/#Configuration-Management","page":"API Reference","title":"Configuration Management","text":"","category":"section"},{"location":"api/#Configuration-Creation","page":"API Reference","title":"Configuration Creation","text":"","category":"section"},{"location":"api/#Index-Utilities","page":"API Reference","title":"Index Utilities","text":"","category":"section"},{"location":"api/#Scalar-Field-Transforms","page":"API Reference","title":"Scalar Field Transforms","text":"","category":"section"},{"location":"api/#Forward-Transform-(Synthesis)","page":"API Reference","title":"Forward Transform (Synthesis)","text":"","category":"section"},{"location":"api/#Backward-Transform-(Analysis)","page":"API Reference","title":"Backward Transform (Analysis)","text":"","category":"section"},{"location":"api/#Complex-Field-Transforms","page":"API Reference","title":"Complex Field Transforms","text":"","category":"section"},{"location":"api/#Vector-Field-Transforms","page":"API Reference","title":"Vector Field Transforms","text":"Vector fields on the sphere are decomposed into spheroidal and toroidal components:\n\nSpheroidal: Poloidal component (has radial component)\nToroidal: Azimuthal component (purely horizontal)","category":"section"},{"location":"api/#Vector-Synthesis","page":"API Reference","title":"Vector Synthesis","text":"","category":"section"},{"location":"api/#Vector-Analysis","page":"API Reference","title":"Vector Analysis","text":"","category":"section"},{"location":"api/#QST-Transforms-(3D-Vector-Fields)","page":"API Reference","title":"QST Transforms (3D Vector Fields)","text":"","category":"section"},{"location":"api/#Rotations","page":"API Reference","title":"Rotations","text":"","category":"section"},{"location":"api/#Energy/Power-Spectrum-Analysis","page":"API Reference","title":"Energy/Power Spectrum Analysis","text":"","category":"section"},{"location":"api/#Threading-Control","page":"API Reference","title":"Threading Control","text":"","category":"section"},{"location":"api/#Buffer-Helpers","page":"API Reference","title":"Buffer Helpers","text":"","category":"section"},{"location":"api/#Distributed-Transforms-(MPI)","page":"API Reference","title":"Distributed Transforms (MPI)","text":"When using MPI with PencilArrays, the following functions are available via the parallel extension:\n\ndist_analysis(cfg, fθφ) - Distributed spatial to spectral transform\ndist_synthesis(cfg, Alm; prototype_θφ, real_output) - Distributed spectral to spatial transform\ndist_spat_to_SHsphtor(cfg, Vθ, Vφ) - Distributed vector analysis\ndist_SHsphtor_to_spat(cfg, Slm, Tlm; prototype_θφ) - Distributed vector synthesis\n\nSee the Distributed Guide for detailed usage.","category":"section"},{"location":"api/#Gradient-and-Differential-Operators","page":"API Reference","title":"Gradient and Differential Operators","text":"","category":"section"},{"location":"api/#Usage-Examples","page":"API Reference","title":"Usage Examples","text":"","category":"section"},{"location":"api/#Basic-Transform","page":"API Reference","title":"Basic Transform","text":"using SHTnsKit\n\nlmax = 16\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create test pattern\nspatial = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat\n    x = cfg.x[i]\n    spatial[i, :] .= (3*x^2 - 1)/2\nend\n\n# Transform roundtrip\nAlm = analysis(cfg, spatial)\nrecovered = synthesis(cfg, Alm)\n\ndestroy_config(cfg)","category":"section"},{"location":"api/#Vector-Field-Transform","page":"API Reference","title":"Vector Field Transform","text":"using SHTnsKit\n\nlmax = 32\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create velocity field\nVθ = zeros(cfg.nlat, cfg.nlon)\nVφ = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    Vθ[i,j] = cos(θ) * sin(φ)\n    Vφ[i,j] = cos(φ)\nend\n\n# Decompose into spheroidal/toroidal\nSlm, Tlm = spat_to_SHsphtor(cfg, Vθ, Vφ)\n\n# Reconstruct\nVθ_rec, Vφ_rec = SHsphtor_to_spat(cfg, Slm, Tlm)\n\ndestroy_config(cfg)","category":"section"},{"location":"api/#Error-Handling","page":"API Reference","title":"Error Handling","text":"","category":"section"},{"location":"api/#Common-Errors","page":"API Reference","title":"Common Errors","text":"BoundsError: Invalid lmax/mmax values\nAssertionError / DimensionMismatch: Array size mismatches","category":"section"},{"location":"api/#Best-Practices","page":"API Reference","title":"Best Practices","text":"# Always check array sizes\n@assert size(Alm) == (cfg.lmax+1, cfg.mmax+1) \"Wrong spectral array size\"\n@assert size(spatial) == (cfg.nlat, cfg.nlon) \"Wrong spatial array size\"\n\n# Always destroy configurations\ncfg = create_gauss_config(32, 34; nlon=65)\n# ... work with cfg ...\ndestroy_config(cfg)","category":"section"},{"location":"api/#SHTnsKit.create_config","page":"API Reference","title":"SHTnsKit.create_config","text":"create_config(lmax::Int; mmax=lmax, mres=1, nlat=lmax+2, nlon=max(2*lmax+1,4),\n               norm::Symbol=:orthonormal, cs_phase::Bool=true,\n               real_norm::Bool=false, robert_form::Bool=false,\n               grid_type::Symbol=:gauss) -> SHTConfig\n\nCompatibility wrapper for configuration creation used in some docs/snippets. Supports Gauss–Legendre (grid_type = :gauss) and regular equiangular (grid_type = :regular or :regular_poles) grids, forwarding to the appropriate creator. nlat/nlon defaults are adjusted to satisfy accuracy constraints for the chosen grid.\n\n\n\n\n\ncreate_config(::Type{T}, lmax::Int, nlat::Int, mres::Int=1; kwargs...) -> SHTConfig\n\nCompatibility method that ignores the element type T and calls create_config. Provided to match older example signatures like create_config(Float64, 20, 22, 1).\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.create_gauss_config","page":"API Reference","title":"SHTnsKit.create_gauss_config","text":"create_gauss_config(lmax::Int, nlat::Int; mmax::Int=lmax, nlon::Int=max(2*lmax+1, 4)) -> SHTConfig\n\nCreate a Gauss–Legendre based SHT configuration. Constraints:\n\nnlat ≥ lmax+1 for exactness up to lmax in θ integration.\nnlon ≥ 2*mmax+1 to resolve azimuthal orders up to mmax.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.create_regular_config","page":"API Reference","title":"SHTnsKit.create_regular_config","text":"create_regular_config(lmax::Int, nlat::Int; mmax::Int=lmax, mres::Int=1,\n                      nlon::Int=max(2*lmax+1, 4), norm::Symbol=:orthonormal,\n                      cs_phase::Bool=true, real_norm::Bool=false,\n                      robert_form::Bool=false, include_poles::Bool=false,\n                      precompute_plm::Bool=true, use_dh_weights::Bool=false) -> SHTConfig\n\nCreate an equiangular (regular) grid configuration. Regular grids use simple θ = (i+0.5)π/nlat nodes by default; set include_poles=true to place nodes directly on the poles. By default associated Legendre tables are precomputed, which mirrors SHTns' regular-grid behaviour and improves performance.\n\nDriscoll-Healy Quadrature\n\nSet use_dh_weights=true to use Driscoll-Healy quadrature for exact spherical harmonic transforms. This requires:\n\ninclude_poles=true\nnlat = 2*(lmax+1) for exactness up to degree lmax\nnlat must be even\n\nThe DH grid uses θ = πj/n for j=0,...,n-1 (includes north pole, excludes south pole) and provides exact quadrature via specially computed weights.\n\nReference: Driscoll & Healy (1994), \"Computing Fourier transforms and convolutions on the 2-sphere\", Adv. Appl. Math., 15, 202-250.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.destroy_config","page":"API Reference","title":"SHTnsKit.destroy_config","text":"destroy_config(cfg::SHTConfig)\n\nNo-op placeholder for API symmetry with libraries that require explicit teardown.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.nlm_calc","page":"API Reference","title":"SHTnsKit.nlm_calc","text":"nlm_calc(lmax::Integer, mmax::Integer, mres::Integer) -> Int\n\nCalculate the total number of packed spectral coefficients for a real scalar field. Real fields only need m ≥ 0 modes due to Hermitian symmetry: Yl^{-m} = (-1)^m (Yl^m)*\n\nThe packing scheme groups modes by m-order, then by l-degree within each m block. This layout is optimized for vectorized operations and cache efficiency.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.LM_index","page":"API Reference","title":"SHTnsKit.LM_index","text":"LM_index(lmax::Int, mres::Int, l::Int, m::Int) -> Int\n\nConvert 2D spherical harmonic indices (l,m) to a 1D packed array index. This implements the SHTns packing convention for efficient memory layout.\n\nThe packing scheme groups coefficients by m-order blocks, with each block containing all valid l-degrees for that m. This enables vectorized operations on modes with the same azimuthal symmetry.\n\nMatches SHTns C macro: LM(shtns, l, m)\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.synthesis","page":"API Reference","title":"SHTnsKit.synthesis","text":"synthesis(cfg::SHTConfig, alm::AbstractMatrix; real_output::Bool=true) -> Matrix\n\nInverse transform back to a grid (nlat, nlon). If real_output=true, Hermitian symmetry is enforced before IFFT. Optional fft_scratch lets you reuse a preallocated (nlat,nlon) complex buffer for lower allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.synthesis!","page":"API Reference","title":"SHTnsKit.synthesis!","text":"synthesis!(plan::SHTPlan, f_out::AbstractMatrix, alm::AbstractMatrix; real_output=true)\n\nIn-place inverse scalar SHT writing spatial field into f_out. Streams m→k directly without building a (θ×m) intermediate.\n\n\n\n\n\nsynthesis!(cfg::SHTConfig, f_out::AbstractMatrix, alm::AbstractMatrix;\n           real_output::Bool=true, use_fused_loops::Bool=true)\n\nIn-place inverse transform. Writes the spatial field into f_out to reduce allocations. f_out must be (nlat, nlon) and real if real_output=true. You may pass a complex fft_scratch buffer of size (nlat,nlon) to reuse FFT workspace.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.analysis","page":"API Reference","title":"SHTnsKit.analysis","text":"analysis(cfg::SHTConfig, f::AbstractMatrix) -> Matrix{ComplexF64}\n\nForward transform on Gauss–Legendre × equiangular grid. Returns coefficients alm[l+1, m+1] with orthonormal normalization.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.analysis!","page":"API Reference","title":"SHTnsKit.analysis!","text":"analysis!(plan::SHTPlan, alm_out::AbstractMatrix, f::AbstractMatrix)\n\nIn-place forward scalar SHT writing coefficients into alm_out.\n\n\n\n\n\nanalysis!(cfg::SHTConfig, alm_out::AbstractMatrix, f::AbstractMatrix; use_fused_loops=true)\n\nIn-place forward transform. Writes coefficients into alm_out to avoid allocating the output matrix each call. alm_out must be size (lmax+1, mmax+1).\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SH_to_spat_cplx","page":"API Reference","title":"SHTnsKit.SH_to_spat_cplx","text":"SH_to_spat_cplx(cfg::SHTConfig, alm_packed::AbstractVector{<:Complex}) -> Matrix{ComplexF64}\n\nSynthesize complex spatial field from packed complex coefficients (LM_cplx order). Returns an nlat × nlon complex array.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.spat_cplx_to_SH","page":"API Reference","title":"SHTnsKit.spat_cplx_to_SH","text":"spat_cplx_to_SH(cfg::SHTConfig, z::AbstractMatrix{<:Complex}) -> Vector{ComplexF64}\n\nAnalyze complex spatial field into packed complex coefficients (LM_cplx order). Input z must be nlat × nlon complex.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SHsphtor_to_spat","page":"API Reference","title":"SHTnsKit.SHsphtor_to_spat","text":"SHsphtor_to_spat(cfg, Slm, Tlm; real_output=true) -> (Vt, Vp)\n\nTransform spheroidal/toroidal coefficients to horizontal vector field components. Returns colatitude (Vt) and azimuthal (Vp) components on the spatial grid.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.spat_to_SHsphtor","page":"API Reference","title":"SHTnsKit.spat_to_SHsphtor","text":"spat_to_SHsphtor(cfg, Vt, Vp) -> (Slm, Tlm)\n\nTransform horizontal vector field components to spheroidal/toroidal coefficients. Input: colatitude (Vt) and azimuthal (Vp) components on spatial grid. The returned coefficients satisfy δlm = −l(l+1) Slm (divergence) and ζlm = −l(l+1) Tlm (vorticity) when expressed in the internal normalization.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SHqst_to_spat","page":"API Reference","title":"SHTnsKit.SHqst_to_spat","text":"SHqst_to_spat(cfg, Qlm, Slm, Tlm; real_output=true) -> (Vr, Vt, Vp)\n\nTransform QST spectral coefficients to 3D spatial vector field components. Returns radial (Vr), colatitude (Vt), and azimuthal (Vp) components.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.spat_to_SHqst","page":"API Reference","title":"SHTnsKit.spat_to_SHqst","text":"spat_to_SHqst(cfg, Vr, Vt, Vp) -> (Qlm, Slm, Tlm)\n\nTransform 3D spatial vector field to QST spectral coefficients. Input: radial (Vr), colatitude (Vt), and azimuthal (Vp) components.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SH_Zrotate","page":"API Reference","title":"SHTnsKit.SH_Zrotate","text":"SH_Zrotate(cfg::SHTConfig, Qlm::AbstractVector{<:Complex}, alpha::Real, Rlm::AbstractVector{<:Complex})\n\nRotate a real-field SH expansion around the Z-axis by angle alpha. Input and output are packed Qlm vectors (LM order, m ≥ 0). In-place supported if Rlm === Qlm.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SH_Yrotate","page":"API Reference","title":"SHTnsKit.SH_Yrotate","text":"SH_Yrotate(cfg::SHTConfig, Qlm::AbstractVector{<:Complex}, alpha::Real, Rlm::AbstractVector{<:Complex})\n\nRotate a real-field SH expansion around the Y-axis by angle alpha. Uses Wigner-d mixing per l; dispatches to the general rotation engine.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SH_Yrotate90","page":"API Reference","title":"SHTnsKit.SH_Yrotate90","text":"SH_Yrotate90(cfg::SHTConfig, Qlm::AbstractVector{<:Complex}, Rlm::AbstractVector{<:Complex})\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SH_Xrotate90","page":"API Reference","title":"SHTnsKit.SH_Xrotate90","text":"SH_Xrotate90(cfg::SHTConfig, Qlm::AbstractVector{<:Complex}, Rlm::AbstractVector{<:Complex})\n\nRotate around X-axis by 90 degrees using ZYZ equivalence: Rz(π/2)·Ry(π/2)·Rz(-π/2).\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.energy_scalar_l_spectrum","page":"API Reference","title":"SHTnsKit.energy_scalar_l_spectrum","text":"energy_scalar_l_spectrum(cfg, alm; real_field=true) -> Vector{Float64}\n\nCompute energy spectrum as a function of spherical harmonic degree l. Returns E(l) = Σₘ |a_lm|² for each l = 0..lmax.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.energy_vector_l_spectrum","page":"API Reference","title":"SHTnsKit.energy_vector_l_spectrum","text":"energy_vector_l_spectrum(cfg, Slm, Tlm; real_field=true) -> Vector{Float64}\n\nCompute kinetic energy spectrum by degree l for vector fields. Returns KE(l) = Σₘ l(l+1)[|Slm|² + |Tlm|²] for each l = 1..lmax.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.energy_scalar","page":"API Reference","title":"SHTnsKit.energy_scalar","text":"energy_scalar(cfg, alm; real_field=true) -> Float64\n\nCompute the total energy of a scalar field from its spherical harmonic coefficients.\n\nFor a scalar field f(θ,φ) = Σ alm Yl^m(θ,φ), the energy is defined as: E = (1/2) ∫ |f|² dΩ = (1/2) Σ |a_lm|²\n\nThis represents the L² norm of the field, which is conserved under orthonormal spherical harmonic transforms (Parseval's identity).\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.energy_vector","page":"API Reference","title":"SHTnsKit.energy_vector","text":"energy_vector(cfg, Slm, Tlm; real_field=true) -> Float64\n\nCompute the total kinetic energy of a vector field from spheroidal/toroidal coefficients.\n\nFor a vector field V = ∇×(T Yl^m êᵣ) + ∇ₕ(S Yl^m), the kinetic energy is: KE = (1/2) ∫ |V|² dΩ = (1/2) Σ [l(l+1)|Slm|² + l(l+1)|Tlm|²]\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.enstrophy","page":"API Reference","title":"SHTnsKit.enstrophy","text":"enstrophy(cfg, Tlm; real_field=true) -> Float64\n\nCompute the enstrophy (kinetic energy of vorticity) from toroidal coefficients.\n\nFor a toroidal field with coefficients Tlm, the enstrophy is: Z = (1/2) ∫ |∇×V|² dΩ = (1/2) Σ l²(l+1)²|Tlm|²\n\nThis is a measure of the small-scale intensity of rotational motion.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.shtns_use_threads","page":"API Reference","title":"SHTnsKit.shtns_use_threads","text":"shtnsusethreads(num_threads) -> Int\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.scratch_spatial","page":"API Reference","title":"SHTnsKit.scratch_spatial","text":"scratch_spatial(cfg::SHTConfig, T::Type=Float64) -> Matrix{T}\n\nAllocate a spatial grid buffer of size (nlat, nlon).\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.scratch_fft","page":"API Reference","title":"SHTnsKit.scratch_fft","text":"scratch_fft(cfg::SHTConfig, T::Type=ComplexF64) -> Matrix{T}\n\nAllocate a complex buffer sized for φ-FFTs (nlat, nlon). Reuse this across analysis!/synthesis! calls via the fft_scratch keyword to avoid per-call allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.SH_to_grad_spat","page":"API Reference","title":"SHTnsKit.SH_to_grad_spat","text":"SH_to_grad_spat(cfg::SHTConfig, Slm::AbstractMatrix; real_output::Bool=true)\n\nGradient synthesis alias for compatibility with SHTns.\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.divergence_from_spheroidal","page":"API Reference","title":"SHTnsKit.divergence_from_spheroidal","text":"divergence_from_spheroidal(cfg, Slm) -> Matrix\n\nReturn divergence spectral coefficients δlm corresponding to spheroidal modes via δlm = −l(l+1) Slm (`δ{00} = 0`).\n\n\n\n\n\n","category":"function"},{"location":"api/#SHTnsKit.vorticity_from_toroidal","page":"API Reference","title":"SHTnsKit.vorticity_from_toroidal","text":"vorticity_from_toroidal(cfg, Tlm) -> Matrix\n\nReturn vorticity spectral coefficients ζlm = −l(l+1) Tlm.\n\n\n\n\n\n","category":"function"},{"location":"performance_tips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"<div style=\"background: linear-gradient(135deg, #ea580c 0%, #f59e0b 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">Performance Tips</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Quick tips for reducing allocations and maximizing throughput</p>\n</div>\n\nThis page summarizes practical tips to reduce allocations and improve locality and throughput in SHTnsKit.jl, especially for distributed (MPI + PencilArrays) use.\n\nReuse plans: Construct SHTPlan (serial) and distributed plans (DistAnalysisPlan, DistSphtorPlan, DistQstPlan) once per size and reuse. Plans hold FFT plans and working buffers to avoid per-call allocations.\nGrid defaults: Gauss grids use phi_scale=:dft (FFT scaling nlon). Regular/Driscoll-Healy grids use phi_scale=:quad (nlon/2π). You can override globally with ENV[\"SHTNSKIT_PHI_SCALE\"]=dft|quad or per-config via phi_scale if you need a specific convention.\nLow-allocation serial recipe: preallocate FFT scratch and outputs.\ncfg = create_gauss_config(32, 34; nlon=129)\nfft_scratch = scratch_fft(cfg)\nalm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nf   = randn(cfg.nlat, cfg.nlon)\nanalysis!(cfg, alm, f; fft_scratch=fft_scratch)      # reuse alm + scratch\nf_out = scratch_spatial(cfg)\nsynthesis!(cfg, f_out, alm; fft_scratch=fft_scratch) # reuse f_out + scratch\nLow-allocation distributed recipe: reuse plans with in-plan scratch.\naplan = DistAnalysisPlan(cfg, proto; use_rfft=true)\nvplan = DistSphtorPlan(cfg, proto; use_rfft=true, with_spatial_scratch=true)\nsplan = DistPlan(cfg, proto; use_rfft=true)\ndist_analysis!(aplan, Alm, fθφ)          # no per-call FFT allocs\ndist_SHsphtor_to_spat!(vplan, Vt, Vp, S, T; real_output=true)\ndist_synthesis!(splan, fθφ, Alm; real_output=true)\nuse_rfft trims the spectral grid; with_spatial_scratch keeps a single complex (θ,φ) buffer inside the vector/QST plans so real outputs don’t allocate a fresh iFFT workspace each call.\nuserfft (distributed plans): When available in your PencilFFTs, set `userfft=true` in distributed plans to cut the (θ,k) spectral memory and accelerate real-output paths. The code falls back to complex FFTs when real transforms are not supported.\nwithspatialscratch (vector/QST): Enable with_spatial_scratch=true to keep a single complex (θ,φ) scratch in the plan. This removes per-call iFFT allocations for real outputs. Default remains off to minimize footprint.\nPrecomputed Legendre tables: On fixed grids, call enable_plm_tables!(cfg) to precompute plm_tables and dplm_tables. They provide identical results to on-the-fly recurrences and usually reduce CPU cost.\nThreading inside rank: For large lmax, enable Julia threads and (optionally) FFTW threads. Use set_optimal_threads!() or tune with set_threading!() and set_fft_threads() to match your core layout.\nLoopVectorization: If available, analysis_turbo/synthesis_turbo and related helpers can accelerate inner loops. Guard with using LoopVectorization.\nData locality by m: Keep Alm distributed by m throughout your pipeline to avoid dense gathers. The distributed plans in this package consume and produce m-sliced data to preserve cache locality.","category":"section"},{"location":"advanced/#Advanced-Usage-Patterns","page":"Advanced Usage","title":"Advanced Usage Patterns","text":"<div style=\"background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">Advanced Techniques</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Sophisticated patterns for experienced users and scientific computing</p>\n</div>\n\nThis guide covers sophisticated usage patterns and advanced techniques for experienced SHTnsKit.jl users.\n\nnote: Prerequisites\nThis guide assumes familiarity with basic SHTnsKit.jl usage. See the Quick Start Guide first if you're new to the package.","category":"section"},{"location":"advanced/#Advanced-Configuration-Management","page":"Advanced Usage","title":"Advanced Configuration Management","text":"","category":"section"},{"location":"advanced/#Configuration-Factories","page":"Advanced Usage","title":"Configuration Factories","text":"using SHTnsKit\n\n# Create a factory for consistent configuration creation\nstruct SHTnsConfigFactory\n    default_lmax::Int\n    cache::Dict{Tuple{Int,Int}, SHTnsConfig}\nend\n\nfunction SHTnsConfigFactory(lmax::Int=64)\n    SHTnsConfigFactory(lmax, Dict())\nend\n\nfunction get_config(factory::SHTnsConfigFactory, lmax::Int, mmax::Int)\n    key = (lmax, mmax)\n    if !haskey(factory.cache, key)\n        cfg = create_gauss_config(lmax, mmax)\n        factory.cache[key] = cfg\n    end\n    return factory.cache[key]\nend\n\nfunction cleanup!(factory::SHTnsConfigFactory)\n    for cfg in values(factory.cache)\n        destroy_config(cfg)\n    end\n    empty!(factory.cache)\nend\n\n# Usage\nfactory = SHTnsConfigFactory()\ncfg32 = get_config(factory, 32, 32)\ncfg64 = get_config(factory, 64, 64)\n# ... use configurations ...\ncleanup!(factory)","category":"section"},{"location":"advanced/#Dynamic-Resolution-Adaptation","page":"Advanced Usage","title":"Dynamic Resolution Adaptation","text":"using SHTnsKit\n\nmutable struct AdaptiveSpectralTransform\n    current_lmax::Int\n    max_lmax::Int\n    configs::Dict{Int, SHTnsConfig}\n    tolerance::Float64\nend\n\nfunction AdaptiveSpectralTransform(max_lmax::Int, tolerance::Float64=1e-10)\n    AdaptiveSpectralTransform(16, max_lmax, Dict{Int, SHTnsConfig}(), tolerance)\nend\n\nfunction get_config!(transform::AdaptiveSpectralTransform, lmax::Int)\n    if !haskey(transform.configs, lmax)\n        transform.configs[lmax] = create_gauss_config(lmax, lmax)\n    end\n    return transform.configs[lmax]\nend\n\nfunction adaptive_analyze(transform::AdaptiveSpectralTransform, field::Matrix{Float64})\n    lmax = transform.current_lmax\n    \n    while lmax <= transform.max_lmax\n        cfg = get_config!(transform, lmax)\n        \n        # Interpolate field to current resolution if needed\n        field_resized = resize_spatial_field(field, cfg)\n        \n        # Analyze\n        sh = analysis(cfg, field_resized)\n        \n        # Check convergence by looking at high-degree coefficients\n        high_degree_power = sum(abs2, sh[end-min(10, div(length(sh), 4)):end])\n        total_power = sum(abs2, sh)\n        \n        if high_degree_power / total_power < transform.tolerance\n            transform.current_lmax = lmax\n            return sh, lmax\n        end\n        \n        lmax = min(lmax * 2, transform.max_lmax)\n    end\n    \n    # Maximum resolution reached\n    cfg = get_config!(transform, transform.max_lmax)\n    field_resized = resize_spatial_field(field, cfg)\n    sh = analysis(cfg, field_resized)\n    transform.current_lmax = transform.max_lmax\n    \n    return sh, transform.max_lmax\nend\n\nfunction cleanup!(transform::AdaptiveSpectralTransform)\n    for cfg in values(transform.configs)\n        destroy_config(cfg)\n    end\n    empty!(transform.configs)\nend","category":"section"},{"location":"advanced/#Spectral-Domain-Operations","page":"Advanced Usage","title":"Spectral Domain Operations","text":"","category":"section"},{"location":"advanced/#Custom-Spectral-Filtering","page":"Advanced Usage","title":"Custom Spectral Filtering","text":"using SHTnsKit\n\nfunction create_spectral_filter(lmax::Int; \n                               low_pass::Union{Int,Nothing}=nothing,\n                               high_pass::Union{Int,Nothing}=nothing,\n                               band_pass::Union{Tuple{Int,Int},Nothing}=nothing)\n    \n    filter = ones(Float64, (lmax+1)*(lmax+2)÷2)\n    \n    cfg_temp = create_gauss_config(lmax, lmax)\n    \n    for i in 1:length(filter)\n        l, m = lm_from_index(cfg_temp, i)\n        \n        if low_pass !== nothing && l > low_pass\n            filter[i] = 0.0\n        elseif high_pass !== nothing && l < high_pass\n            filter[i] = 0.0\n        elseif band_pass !== nothing\n            l_min, l_max = band_pass\n            if l < l_min || l > l_max\n                filter[i] = 0.0\n            end\n        end\n    end\n    \n    destroy_config(cfg_temp)\n    return filter\nend\n\nfunction apply_spectral_filter!(sh::Vector{Float64}, filter::Vector{Float64})\n    @assert length(sh) == length(filter) \"Filter size mismatch\"\n    sh .*= filter\n    return sh\nend\n\n# Example: Smooth a noisy field\ncfg = create_gauss_config(64, 64)\n# Create bandlimited test field (smooth function suitable for SHT)\nθ, φ = cfg.θ, cfg.φ\nnoisy_field = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    noisy_field[i,j] = 1.0 + 0.3 * sin(3*θ[i]) * cos(2*φ[j]) + 0.1 * cos(5*θ[i])\nend\n\n# Low-pass filter (keep only l ≤ 20)\nsh = analysis(cfg, noisy_field)\nlowpass_filter = create_spectral_filter(64, low_pass=20)\napply_spectral_filter!(sh, lowpass_filter)\nsmooth_field = synthesis(cfg, sh)\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Spectral-Derivative-Operations","page":"Advanced Usage","title":"Spectral Derivative Operations","text":"SHTnsKit provides spectral methods for computing derivatives, which are more accurate than finite differences. All operations support MPI parallelization with PencilArrays.","category":"section"},{"location":"advanced/#Serial-Gradient-Computation","page":"Advanced Usage","title":"Serial Gradient Computation","text":"using SHTnsKit\n\n# Setup configuration\nlmax = 32\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create test field: Y_2^1-like pattern\ntest_field = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    test_field[i,j] = sin(θ) * cos(θ) * cos(φ)  # ∝ Y_2^1\nend\n\n# Transform to spectral coefficients\nAlm = analysis(cfg, test_field)\n\n# Compute gradient using spectral method (exact derivatives)\n# SH_to_grad_spat computes ∇f = (∂f/∂θ, (1/sinθ)∂f/∂φ)\n∂f_∂θ, ∂f_∂φ_over_sinθ = SH_to_grad_spat(cfg, Alm)\n\nprintln(\"Gradient computed using spectral method:\")\nprintln(\"  ∂f/∂θ range: \", extrema(∂f_∂θ))\nprintln(\"  (1/sinθ)∂f/∂φ range: \", extrema(∂f_∂φ_over_sinθ))\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#MPI-Parallel-Gradient-Computation","page":"Advanced Usage","title":"MPI-Parallel Gradient Computation","text":"using MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\n\n# Setup configuration\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed array using PencilArrays\npen = Pencil((nlat, nlon), comm)\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill local portion with test pattern\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    θ = cfg.θ[i_global]\n    for (j_local, j_global) in enumerate(ranges[2])\n        φ = cfg.φ[j_global]\n        fθφ[i_local, j_local] = sin(θ) * cos(θ) * cos(φ)\n    end\nend\n\n# Distributed analysis: spatial → spectral\nAlm = SHTnsKit.dist_analysis(cfg, fθφ)\n\n# Compute gradient using distributed synthesis with spheroidal transform\n# Gradient = (∂f/∂θ, (1/sinθ)∂f/∂φ) via spheroidal synthesis\nTlm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)  # Zero toroidal component\n∂f_∂θ, ∂f_∂φ_over_sinθ = SHTnsKit.dist_SHsphtor_to_spat(cfg, Alm, Tlm; prototype_θφ=fθφ)\n\nif rank == 0\n    println(\"Distributed gradient computed successfully\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()","category":"section"},{"location":"advanced/#Serial-Laplacian","page":"Advanced Usage","title":"Serial Laplacian","text":"The Laplacian has a simple form in spectral space: ∇²f_lm = -l(l+1) f_lm\n\nusing SHTnsKit\n\nlmax = 32\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create test field (Y_2^0)\ntest_field = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat\n    x = cfg.x[i]  # cos(θ)\n    test_field[i, :] .= (3*x^2 - 1)/2\nend\n\n# Transform to spectral\nAlm = analysis(cfg, test_field)\n\n# Apply Laplacian in spectral space: multiply by -l(l+1)\nLaplacian_Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nfor l in 0:cfg.lmax\n    for m in 0:min(l, cfg.mmax)\n        Laplacian_Alm[l+1, m+1] = -l * (l + 1) * Alm[l+1, m+1]\n    end\nend\n\n# Transform back to spatial domain\nlaplacian_field = synthesis(cfg, Laplacian_Alm)\n\n# For Y_2^0, the Laplacian should be -2(2+1) = -6 times the original\nprintln(\"Ratio (should be ≈ -6): \", laplacian_field[cfg.nlat÷2, 1] / test_field[cfg.nlat÷2, 1])\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#MPI-Parallel-Laplacian","page":"Advanced Usage","title":"MPI-Parallel Laplacian","text":"using MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\n\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed array\npen = Pencil((nlat, nlon), comm)\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with Y_2^0 pattern\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    x = cfg.x[i_global]\n    for j_local in 1:length(ranges[2])\n        fθφ[i_local, j_local] = (3*x^2 - 1)/2\n    end\nend\n\n# Compute distributed Laplacian (uses spectral method internally)\nlaplacian_fθφ = SHTnsKit.dist_scalar_laplacian(cfg, fθφ; prototype_θφ=fθφ)\n\nif rank == 0\n    println(\"Distributed Laplacian computed\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()","category":"section"},{"location":"advanced/#Serial-Divergence-and-Vorticity","page":"Advanced Usage","title":"Serial Divergence and Vorticity","text":"using SHTnsKit\n\nlmax = 32\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create a velocity field\nVθ = zeros(cfg.nlat, cfg.nlon)\nVφ = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    Vθ[i,j] = cos(θ) * sin(φ)\n    Vφ[i,j] = cos(φ)\nend\n\n# Decompose into spheroidal/toroidal\nSlm, Tlm = spat_to_SHsphtor(cfg, Vθ, Vφ)\n\n# Compute divergence and vorticity\ndiv_field = divergence_from_spheroidal(cfg, Slm)\nvort_field = vorticity_from_toroidal(cfg, Tlm)\n\nprintln(\"Divergence range: \", extrema(div_field))\nprintln(\"Vorticity range: \", extrema(vort_field))\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#MPI-Parallel-Divergence-and-Vorticity","page":"Advanced Usage","title":"MPI-Parallel Divergence and Vorticity","text":"using MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\n\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed velocity field components\npen = Pencil((nlat, nlon), comm)\nVtθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\nVpθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test velocity field\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    θ = cfg.θ[i_global]\n    for (j_local, j_global) in enumerate(ranges[2])\n        φ = cfg.φ[j_global]\n        Vtθφ[i_local, j_local] = cos(θ) * sin(φ)\n        Vpθφ[i_local, j_local] = cos(φ)\n    end\nend\n\n# Compute distributed divergence directly\ndiv_field = SHTnsKit.dist_spatial_divergence(cfg, Vtθφ, Vpθφ; prototype_θφ=Vtθφ)\n\n# Compute distributed vorticity directly\nvort_field = SHTnsKit.dist_spatial_vorticity(cfg, Vtθφ, Vpθφ; prototype_θφ=Vtθφ)\n\nif rank == 0\n    println(\"Distributed divergence and vorticity computed\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()","category":"section"},{"location":"advanced/#Running-MPI-Examples","page":"Advanced Usage","title":"Running MPI Examples","text":"Save as gradient_mpi.jl and run with:\n\nmpiexec -n 4 julia --project gradient_mpi.jl","category":"section"},{"location":"advanced/#Multi-Field-Processing-Patterns","page":"Advanced Usage","title":"Multi-Field Processing Patterns","text":"","category":"section"},{"location":"advanced/#Coherent-Transform-Pipeline","page":"Advanced Usage","title":"Coherent Transform Pipeline","text":"using SHTnsKit\n\nstruct SpectralPipeline\n    cfg::SHTnsConfig\n    stages::Vector{Function}\n    buffers::Dict{Symbol, Any}\nend\n\nfunction SpectralPipeline(lmax::Int, mmax::Int)\n    cfg = create_gauss_config(lmax, mmax)\n    stages = Function[]\n    buffers = Dict{Symbol, Any}()\n    \n    # Pre-allocate common buffers\n    buffers[:sh_temp] = allocate_spectral(cfg)\n    buffers[:spatial_temp] = allocate_spatial(cfg)\n    \n    SpectralPipeline(cfg, stages, buffers)\nend\n\nfunction add_stage!(pipeline::SpectralPipeline, stage_func::Function)\n    push!(pipeline.stages, stage_func)\nend\n\nfunction process(pipeline::SpectralPipeline, input_field::Matrix{Float64})\n    # Initial analysis\n    analyze!(pipeline.cfg, input_field, pipeline.buffers[:sh_temp])\n    \n    # Apply all stages\n    for stage in pipeline.stages\n        stage(pipeline.cfg, pipeline.buffers)\n    end\n    \n    # Final synthesis\n    synthesize!(pipeline.cfg, pipeline.buffers[:sh_temp], pipeline.buffers[:spatial_temp])\n    \n    return copy(pipeline.buffers[:spatial_temp])\nend\n\nfunction cleanup!(pipeline::SpectralPipeline)\n    destroy_config(pipeline.cfg)\nend\n\n# Example pipeline: smooth -> amplify low modes -> threshold\npipeline = SpectralPipeline(32, 32)\n\n# Stage 1: Low-pass filter\nadd_stage!(pipeline, function(cfg, buffers)\n    sh = buffers[:sh_temp]\n    for i in 1:length(sh)\n        l, m = lm_from_index(cfg, i)\n        if l > 16\n            sh[i] = 0.0\n        end\n    end\nend)\n\n# Stage 2: Amplify low modes\nadd_stage!(pipeline, function(cfg, buffers)\n    sh = buffers[:sh_temp]\n    for i in 1:length(sh)\n        l, m = lm_from_index(cfg, i)\n        if l <= 8\n            sh[i] *= 2.0\n        end\n    end\nend)\n\n# Process data\ntest_field = rand(get_nlat(pipeline.cfg), get_nphi(pipeline.cfg))\nresult = process(pipeline, test_field)\n\ncleanup!(pipeline)","category":"section"},{"location":"advanced/#Batch-Transform-Manager","page":"Advanced Usage","title":"Batch Transform Manager","text":"using SHTnsKit\nusing Base.Threads\n\nstruct BatchTransformManager\n    configs::Dict{Int, SHTnsConfig}\n    thread_buffers::Vector{Dict{Symbol, Any}}\n    max_lmax::Int\nend\n\nfunction BatchTransformManager(max_lmax::Int=128)\n    configs = Dict{Int, SHTnsConfig}()\n    thread_buffers = [Dict{Symbol, Any}() for _ in 1:nthreads()]\n    BatchTransformManager(configs, thread_buffers, max_lmax)\nend\n\nfunction get_config!(manager::BatchTransformManager, lmax::Int)\n    if !haskey(manager.configs, lmax)\n        manager.configs[lmax] = create_gauss_config(lmax, lmax)\n    end\n    return manager.configs[lmax]\nend\n\nfunction get_buffers!(manager::BatchTransformManager, thread_id::Int, lmax::Int)\n    buffers = manager.thread_buffers[thread_id]\n    key = Symbol(\"buffers_$lmax\")\n    \n    if !haskey(buffers, key)\n        cfg = get_config!(manager, lmax)\n        buffers[key] = Dict(\n            :sh => allocate_spectral(cfg),\n            :spatial => allocate_spatial(cfg)\n        )\n    end\n    \n    return buffers[key]\nend\n\nfunction batch_process(manager::BatchTransformManager, \n                      fields::Vector{Matrix{Float64}}, \n                      lmax::Int,\n                      process_func::Function)\n    \n    results = Vector{Any}(undef, length(fields))\n    cfg = get_config!(manager, lmax)\n    \n    @threads for i in 1:length(fields)\n        thread_id = threadid()\n        buffers = get_buffers!(manager, thread_id, lmax)\n        \n        # Resize field if necessary\n        field = fields[i]\n        if size(field) != (cfg.nlat, cfg.nlon)\n            field = resize_spatial_field(field, cfg)\n        end\n        \n        # Transform\n        analyze!(cfg, field, buffers[:sh])\n        \n        # Process in spectral domain\n        result_sh = process_func(cfg, buffers[:sh])\n        \n        # Transform back\n        synthesize!(cfg, result_sh, buffers[:spatial])\n        \n        results[i] = copy(buffers[:spatial])\n    end\n    \n    return results\nend\n\nfunction cleanup!(manager::BatchTransformManager)\n    for cfg in values(manager.configs)\n        destroy_config(cfg)\n    end\n    empty!(manager.configs)\nend\n\n# Example: Batch low-pass filtering\nmanager = BatchTransformManager()\n\n# Generate test data\ntest_fields = [rand(65, 129) for _ in 1:100]\n\n# Process function: low-pass filter\nfunction lowpass_filter(cfg, sh)\n    result = copy(sh)\n    for i in 1:length(result)\n        l, m = lm_from_index(cfg, i)\n        if l > 20\n            result[i] = 0.0\n        end\n    end\n    return result\nend\n\n# Process batch\nfiltered_fields = batch_process(manager, test_fields, 64, lowpass_filter)\n\nprintln(\"Processed $(length(filtered_fields)) fields\")\n\ncleanup!(manager)","category":"section"},{"location":"advanced/#Advanced-Vector-Field-Analysis","page":"Advanced Usage","title":"Advanced Vector Field Analysis","text":"","category":"section"},{"location":"advanced/#Helmholtz-Decomposition","page":"Advanced Usage","title":"Helmholtz Decomposition","text":"using SHTnsKit\n\nfunction helmholtz_decomposition(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Decompose vector field into rotational and divergent parts\n    # u = u_rot + u_div, v = v_rot + v_div\n    \n    # Get spheroidal and toroidal components\n    S_lm, T_lm = analyze_vector(cfg, u, v)\n    \n    # Rotational part (from toroidal component)\n    u_rot, v_rot = synthesize_vector(cfg, zeros(length(S_lm)), T_lm)\n    \n    # Divergent part (from spheroidal component)  \n    u_div, v_div = synthesize_vector(cfg, S_lm, zeros(length(T_lm)))\n    \n    return (u_rot, v_rot), (u_div, v_div), (S_lm, T_lm)\nend\n\nfunction vector_field_properties(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Compute various properties of vector field\n    \n    (u_rot, v_rot), (u_div, v_div), (S_lm, T_lm) = helmholtz_decomposition(cfg, u, v)\n    \n    # Energy in each component\n    rot_energy = sum(u_rot.^2 + v_rot.^2)\n    div_energy = sum(u_div.^2 + v_div.^2)\n    total_energy = sum(u.^2 + v.^2)\n    \n    # Spectral energies\n    spheroidal_energy = sum(abs2, S_lm)\n    toroidal_energy = sum(abs2, T_lm)\n    \n    return Dict(\n        :rotational_fraction => rot_energy / total_energy,\n        :divergent_fraction => div_energy / total_energy,\n        :spheroidal_energy => spheroidal_energy,\n        :toroidal_energy => toroidal_energy,\n        :total_spectral_energy => spheroidal_energy + toroidal_energy\n    )\nend\n\n# Example analysis\ncfg = create_gauss_config(48, 48)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Create test vector field with known properties\nu = @. 10 * sin(2θ) * cos(φ)    # Mostly divergent\nv = @. 5 * cos(θ) * sin(2φ)     # Mixed\n\nproperties = vector_field_properties(cfg, u, v)\n\nprintln(\"Vector Field Analysis:\")\nfor (key, value) in properties\n    println(\"  $key: $value\")\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Enstrophy-and-Energy-Cascade-Analysis","page":"Advanced Usage","title":"Enstrophy and Energy Cascade Analysis","text":"using SHTnsKit\n\nfunction compute_enstrophy_spectrum(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Enstrophy Z(l) = l(l+1) * |ω_l|² where ω is vorticity\n    \n    # Get toroidal component (related to vorticity)\n    S_lm, T_lm = analyze_vector(cfg, u, v)\n    \n    # Compute enstrophy per degree\n    lmax = get_lmax(cfg)\n    enstrophy = zeros(lmax + 1)\n    \n    for i in 1:length(T_lm)\n        l, m = lm_from_index(cfg, i)\n        enstrophy[l + 1] += l * (l + 1) * abs2(T_lm[i])\n    end\n    \n    return enstrophy\nend\n\nfunction compute_energy_spectrum(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Kinetic energy E(l) = |u_l|²\n    \n    S_lm, T_lm = analyze_vector(cfg, u, v)\n    \n    lmax = get_lmax(cfg)\n    energy = zeros(lmax + 1)\n    \n    for i in 1:length(S_lm)\n        l, m = lm_from_index(cfg, i)\n        energy[l + 1] += abs2(S_lm[i]) + abs2(T_lm[i])\n    end\n    \n    return energy\nend\n\nfunction analyze_turbulent_cascade(cfg::SHTnsConfig, \n                                  velocity_fields::Vector{Tuple{Matrix{Float64}, Matrix{Float64}}})\n    # Analyze energy cascade in turbulent flow\n    \n    n_snapshots = length(velocity_fields)\n    lmax = get_lmax(cfg)\n    \n    mean_energy = zeros(lmax + 1)\n    mean_enstrophy = zeros(lmax + 1)\n    \n    for (u, v) in velocity_fields\n        energy = compute_energy_spectrum(cfg, u, v)\n        enstrophy = compute_enstrophy_spectrum(cfg, u, v)\n        \n        mean_energy .+= energy\n        mean_enstrophy .+= enstrophy\n    end\n    \n    mean_energy ./= n_snapshots\n    mean_enstrophy ./= n_snapshots\n    \n    # Find inertial range (power law behavior)\n    degrees = 1:lmax\n    \n    return Dict(\n        :degrees => degrees,\n        :energy_spectrum => mean_energy[2:end],  # Skip l=0\n        :enstrophy_spectrum => mean_enstrophy[2:end],\n        :energy_slope => fit_power_law_slope(degrees[5:end÷2], mean_energy[6:end÷2+1]),\n        :enstrophy_slope => fit_power_law_slope(degrees[5:end÷2], mean_enstrophy[6:end÷2+1])\n    )\nend\n\nfunction fit_power_law_slope(x, y)\n    # Simple linear fit in log-log space\n    log_x = log.(x)\n    log_y = log.(y[y .> 0])  # Avoid log(0)\n    \n    if length(log_y) < 2\n        return NaN\n    end\n    \n    # Linear regression\n    n = length(log_x)\n    sum_x = sum(log_x)\n    sum_y = sum(log_y[1:length(log_x)])\n    sum_xy = sum(log_x .* log_y[1:length(log_x)])\n    sum_x2 = sum(log_x.^2)\n    \n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x^2)\n    return slope\nend","category":"section"},{"location":"advanced/#Temporal-Evolution-and-Time-Series","page":"Advanced Usage","title":"Temporal Evolution and Time Series","text":"","category":"section"},{"location":"advanced/#Spectral-Time-Series-Analysis","page":"Advanced Usage","title":"Spectral Time Series Analysis","text":"using SHTnsKit\nusing FFTW\n\nstruct SpectralTimeSeries\n    cfg::SHTnsConfig\n    time_series::Vector{Vector{Float64}}  # Each element is sh coefficients\n    times::Vector{Float64}\n    lmax::Int\nend\n\nfunction SpectralTimeSeries(cfg::SHTnsConfig)\n    SpectralTimeSeries(cfg, Vector{Float64}[], Float64[], get_lmax(cfg))\nend\n\nfunction add_snapshot!(sts::SpectralTimeSeries, field::Matrix{Float64}, time::Float64)\n    sh = analyze(sts.cfg, field)\n    push!(sts.time_series, sh)\n    push!(sts.times, time)\nend\n\nfunction temporal_power_spectrum(sts::SpectralTimeSeries, l::Int, m::Int)\n    # Get time evolution of specific (l,m) mode\n    idx = lmidx(sts.cfg, l, m)\n    \n    mode_evolution = [sh[idx] for sh in sts.time_series]\n    \n    # Compute temporal Fourier transform\n    fft_result = fft(mode_evolution)\n    power_spectrum = abs2.(fft_result)\n    \n    # Frequency axis\n    dt = length(sts.times) > 1 ? sts.times[2] - sts.times[1] : 1.0\n    frequencies = fftfreq(length(mode_evolution), 1/dt)\n    \n    return frequencies, power_spectrum\nend\n\nfunction mode_correlation_matrix(sts::SpectralTimeSeries)\n    # Compute correlation between different spherical harmonic modes\n    \n    n_modes = length(sts.time_series[1])\n    n_times = length(sts.time_series)\n    \n    # Create matrix: modes × time\n    mode_matrix = zeros(n_modes, n_times)\n    for (i, sh) in enumerate(sts.time_series)\n        mode_matrix[:, i] = sh\n    end\n    \n    # Compute correlation matrix\n    correlation_matrix = cor(mode_matrix')\n    \n    return correlation_matrix\nend\n\nfunction dominant_mode_evolution(sts::SpectralTimeSeries, n_modes::Int=10)\n    # Find most energetic modes and track their evolution\n    \n    # Compute mean energy per mode\n    mean_energies = zeros(length(sts.time_series[1]))\n    for sh in sts.time_series\n        mean_energies .+= abs2.(sh)\n    end\n    mean_energies ./= length(sts.time_series)\n    \n    # Find dominant modes\n    dominant_indices = sortperm(mean_energies, rev=true)[1:n_modes]\n    \n    # Extract evolution\n    evolutions = []\n    for idx in dominant_indices\n        l, m = lm_from_index(sts.cfg, idx)\n        evolution = [sh[idx] for sh in sts.time_series]\n        push!(evolutions, (l=l, m=m, evolution=evolution, mean_energy=mean_energies[idx]))\n    end\n    \n    return evolutions\nend\n\n# Example usage\ncfg = create_gauss_config(32, 32)\nsts = SpectralTimeSeries(cfg)\n\n# Generate synthetic time series (e.g., decaying turbulence)\nfor t in 0:0.1:10.0\n    # Synthetic field with time evolution\n    θ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n    decay_factor = exp(-0.1 * t)\n    field = decay_factor * (\n        sin(3θ) .* cos(2φ) +\n        0.5 * sin(5θ) .* cos(4φ) * cos(0.5π * t) +\n        randn(size(θ)...) * 0.1\n    )\n    \n    add_snapshot!(sts, field, t)\nend\n\n# Analysis\ndominant_modes = dominant_mode_evolution(sts, 5)\nfor mode in dominant_modes\n    println(\"Mode l=$(mode.l), m=$(mode.m): mean energy = $(mode.mean_energy)\")\nend\n\n# Temporal spectrum of dominant mode\nif length(dominant_modes) > 0\n    l, m = dominant_modes[1].l, dominant_modes[1].m\n    freqs, power = temporal_power_spectrum(sts, l, m)\n    println(\"Temporal spectrum computed for mode ($l, $m)\")\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Custom-Interpolation-and-Remapping","page":"Advanced Usage","title":"Custom Interpolation and Remapping","text":"","category":"section"},{"location":"advanced/#Adaptive-Mesh-Refinement-Interface","page":"Advanced Usage","title":"Adaptive Mesh Refinement Interface","text":"using SHTnsKit\n\nstruct AdaptiveMesh\n    base_cfg::SHTnsConfig\n    refined_regions::Vector{Dict{Symbol, Any}}\n    global_field::Union{Vector{Float64}, Nothing}\nend\n\nfunction AdaptiveMesh(base_lmax::Int)\n    base_cfg = create_gauss_config(base_lmax, base_lmax)\n    AdaptiveMesh(base_cfg, Dict{Symbol, Any}[], nothing)\nend\n\nfunction add_refined_region!(mesh::AdaptiveMesh, \n                           θ_center::Float64, φ_center::Float64, \n                           radius::Float64, refinement_lmax::Int)\n    \n    refined_cfg = create_gauss_config(refinement_lmax, refinement_lmax)\n    \n    region = Dict(\n        :center => (θ_center, φ_center),\n        :radius => radius,\n        :cfg => refined_cfg,\n        :lmax => refinement_lmax,\n        :local_field => nothing\n    )\n    \n    push!(mesh.refined_regions, region)\nend\n\nfunction interpolate_to_refined_region!(mesh::AdaptiveMesh, region_idx::Int)\n    if mesh.global_field === nothing\n        error(\"No global field set\")\n    end\n    \n    region = mesh.refined_regions[region_idx]\n    base_spatial = synthesize(mesh.base_cfg, mesh.global_field)\n    \n    # Extract region from global field (simplified interpolation)\n    θ_global, φ_global = SHTnsKit.create_coordinate_matrices(mesh.base_cfg)\n    θ_local, φ_local = SHTnsKit.create_coordinate_matrices(region[:cfg])\n    \n    # Simple nearest-neighbor interpolation (in practice, use proper interpolation)\n    local_spatial = zeros(size(θ_local))\n    \n    for i in 1:size(θ_local, 1), j in 1:size(θ_local, 2)\n        # Find nearest point in global grid\n        distances = (θ_global .- θ_local[i,j]).^2 + (φ_global .- φ_local[i,j]).^2\n        min_idx = argmin(distances)\n        local_spatial[i,j] = base_spatial[min_idx]\n    end\n    \n    # Analyze to get local spectral representation\n    region[:local_field] = analyze(region[:cfg], local_spatial)\nend\n\nfunction project_refined_to_global!(mesh::AdaptiveMesh, region_idx::Int)\n    region = mesh.refined_regions[region_idx]\n    \n    if region[:local_field] === nothing\n        error(\"No refined field in region $region_idx\")\n    end\n    \n    # Convert refined solution back to global grid\n    local_spatial = synthesize(region[:cfg], region[:local_field])\n    \n    # Project onto global spectral representation\n    # This requires careful handling of overlapping regions\n    \n    global_spatial = synthesize(mesh.base_cfg, mesh.global_field)\n    \n    # Weighted blending (simplified)\n    θ_center, φ_center = region[:center]\n    radius = region[:radius]\n    \n    θ_global, φ_global = SHTnsKit.create_coordinate_matrices(mesh.base_cfg)\n    θ_local, φ_local = SHTnsKit.create_coordinate_matrices(region[:cfg])\n    \n    # Apply refined solution in the local region\n    # (Proper implementation would use overlap integrals)\n    \n    mesh.global_field = analyze(mesh.base_cfg, global_spatial)\nend\n\nfunction cleanup!(mesh::AdaptiveMesh)\n    destroy_config(mesh.base_cfg)\n    for region in mesh.refined_regions\n        destroy_config(region[:cfg])\n    end\nend","category":"section"},{"location":"advanced/#Memory-Mapped-Large-Dataset-Processing","page":"Advanced Usage","title":"Memory-Mapped Large Dataset Processing","text":"using SHTnsKit\nusing Mmap\n\nstruct MemoryMappedSpectralData\n    file_path::String\n    cfg::SHTnsConfig\n    n_snapshots::Int\n    nlm::Int\n    mmap_array::Array{Float64, 2}  # nlm × n_snapshots\nend\n\nfunction create_mmap_spectral_data(file_path::String, cfg::SHTnsConfig, n_snapshots::Int)\n    nlm = cfg.nlm\n    \n    # Create memory-mapped file\n    file_size = nlm * n_snapshots * sizeof(Float64)\n    \n    open(file_path, \"w+\") do io\n        write(io, zeros(UInt8, file_size))\n    end\n    \n    # Memory map the file\n    mmap_array = Mmap.mmap(file_path, Array{Float64, 2}, (nlm, n_snapshots))\n    \n    MemoryMappedSpectralData(file_path, cfg, n_snapshots, nlm, mmap_array)\nend\n\nfunction add_snapshot!(mmsd::MemoryMappedSpectralData, \n                      spatial_field::Matrix{Float64}, \n                      snapshot_idx::Int)\n    if snapshot_idx > mmsd.n_snapshots\n        error(\"Snapshot index $snapshot_idx exceeds capacity $(mmsd.n_snapshots)\")\n    end\n    \n    # Analyze and store directly in memory-mapped array\n    sh = analyze(mmsd.cfg, spatial_field)\n    mmsd.mmap_array[:, snapshot_idx] = sh\nend\n\nfunction process_snapshots_streaming(mmsd::MemoryMappedSpectralData, \n                                   process_func::Function,\n                                   chunk_size::Int=100)\n    results = []\n    \n    n_chunks = div(mmsd.n_snapshots, chunk_size)\n    \n    for chunk in 1:n_chunks\n        start_idx = (chunk - 1) * chunk_size + 1\n        end_idx = min(chunk * chunk_size, mmsd.n_snapshots)\n        \n        # Process chunk\n        chunk_data = mmsd.mmap_array[:, start_idx:end_idx]\n        chunk_result = process_func(mmsd.cfg, chunk_data)\n        push!(results, chunk_result)\n        \n        # Optional: trigger garbage collection\n        if chunk % 10 == 0\n            GC.gc()\n        end\n    end\n    \n    return results\nend\n\nfunction compute_temporal_statistics(mmsd::MemoryMappedSpectralData)\n    # Compute statistics without loading all data into memory\n    \n    mean_spectrum = zeros(mmsd.nlm)\n    var_spectrum = zeros(mmsd.nlm)\n    \n    # First pass: compute mean\n    for i in 1:mmsd.n_snapshots\n        mean_spectrum .+= mmsd.mmap_array[:, i]\n    end\n    mean_spectrum ./= mmsd.n_snapshots\n    \n    # Second pass: compute variance\n    for i in 1:mmsd.n_snapshots\n        diff = mmsd.mmap_array[:, i] - mean_spectrum\n        var_spectrum .+= diff.^2\n    end\n    var_spectrum ./= (mmsd.n_snapshots - 1)\n    \n    return mean_spectrum, sqrt.(var_spectrum)\nend\n\nfunction cleanup!(mmsd::MemoryMappedSpectralData)\n    # Close memory mapping and optionally remove file\n    finalize(mmsd.mmap_array)\n    # rm(mmsd.file_path)  # Uncomment to delete file\nend\n\n# Example: Process large climate dataset\n# cfg = create_gauss_config(128, 128)\n# n_years = 100\n# n_snapshots_per_year = 365\n# total_snapshots = n_years * n_snapshots_per_year\n\n# mmsd = create_mmap_spectral_data(\"climate_data.bin\", cfg, total_snapshots)\n\n# # Add data (in practice, this would come from files)\n# for i in 1:total_snapshots\n#     synthetic_field = generate_climate_snapshot(i)  # User function\n#     add_snapshot!(mmsd, synthetic_field, i)\n# end\n\n# # Compute statistics\n# mean_spec, std_spec = compute_temporal_statistics(mmsd)\n\n# cleanup!(mmsd)\n# destroy_config(cfg)","category":"section"},{"location":"advanced/#Integration-with-External-Libraries","page":"Advanced Usage","title":"Integration with External Libraries","text":"","category":"section"},{"location":"advanced/#Interfacing-with-Climate-Models","page":"Advanced Usage","title":"Interfacing with Climate Models","text":"using SHTnsKit\n# using NCDatasets  # For NetCDF files\n\nfunction read_climate_model_output(file_path::String, variable::String, time_index::Int)\n    # Read data from NetCDF file (pseudo-code)\n    # In practice, use NCDatasets.jl or similar\n    \n    # data = NCDatasets.Dataset(file_path) do ds\n    #     ds[variable][:, :, time_index]\n    # end\n    \n    # For demonstration, create synthetic data\n    nlat, nlon = 96, 192  # Typical climate model resolution\n    data = rand(nlat, nlon)\n    \n    return data\nend\n\nfunction climate_model_to_shtns(data::Matrix{Float64}, target_lmax::Int)\n    # Convert climate model grid to SHTns format\n    \n    input_nlat, input_nlon = size(data)\n    \n    # Create appropriate configuration\n    cfg = create_regular_config(target_lmax, target_lmax)\n    target_nlat, target_nlon = cfg.nlat, cfg.nlon\n    \n    # Interpolate to target grid (simplified)\n    if (input_nlat, input_nlon) != (target_nlat, target_nlon)\n        # Bilinear interpolation (in practice, use proper spherical interpolation)\n        data_interpolated = imresize(data, (target_nlat, target_nlon))\n    else\n        data_interpolated = data\n    end\n    \n    # Analyze\n    sh = analysis(cfg, data_interpolated)\n    \n    return cfg, sh\nend\n\nfunction process_climate_ensemble(file_paths::Vector{String}, \n                                variable::String, \n                                target_lmax::Int)\n    \n    ensemble_spectra = []\n    reference_cfg = nothing\n    \n    for file_path in file_paths\n        println(\"Processing: $file_path\")\n        \n        # Read multiple time steps\n        n_time_steps = get_time_dimension_size(file_path)  # User function\n        \n        for t in 1:min(n_time_steps, 100)  # Limit for example\n            data = read_climate_model_output(file_path, variable, t)\n            cfg, sh = climate_model_to_shtns(data, target_lmax)\n            \n            if reference_cfg === nothing\n                reference_cfg = cfg\n            end\n            \n            push!(ensemble_spectra, sh)\n        end\n    end\n    \n    return reference_cfg, ensemble_spectra\nend\n\n# Example usage\n# file_paths = [\"model1_output.nc\", \"model2_output.nc\", \"model3_output.nc\"]\n# cfg, ensemble = process_climate_ensemble(file_paths, \"temperature\", 64)\n\n# # Compute ensemble statistics\n# n_members = length(ensemble)\n# mean_spectrum = sum(ensemble) / n_members\n# variance_spectrum = sum([(sp - mean_spectrum).^2 for sp in ensemble]) / (n_members - 1)\n\n# println(\"Ensemble analysis complete\")\n# destroy_config(cfg)","category":"section"},{"location":"advanced/#Automatic-Differentiation-Integration","page":"Advanced Usage","title":"Automatic Differentiation Integration","text":"SHTnsKit.jl provides seamless integration with Julia's automatic differentiation ecosystem through package extensions for ForwardDiff.jl and Zygote.jl.","category":"section"},{"location":"advanced/#ForwardDiff.jl-Support-(Forward-Mode-AD)","page":"Advanced Usage","title":"ForwardDiff.jl Support (Forward-Mode AD)","text":"Forward-mode automatic differentiation is ideal for functions with few inputs and many outputs, common in parameter estimation problems.\n\nusing SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(16, 16)\n\n# Example: Parameter estimation for spherical harmonic coefficients\nfunction objective(params)\n    # Create spherical harmonic field from parameters\n    sh = zeros(cfg.nlm)\n    sh[1:length(params)] = params\n    \n    # Transform to spatial domain\n    spatial = synthesis(cfg, sh)\n    \n    # Compute some objective (e.g., match target pattern)\n    target = rand(size(spatial))\n    return sum((spatial - target).^2)\nend\n\n# Initial parameters\nparams₀ = rand(10)\n\n# Compute gradient using ForwardDiff\n∇f = ForwardDiff.gradient(objective, params₀)\n\n# Use gradient for optimization\nparams₁ = params₀ - 0.01 * ∇f\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Zygote.jl-Support-(Reverse-Mode-AD)","page":"Advanced Usage","title":"Zygote.jl Support (Reverse-Mode AD)","text":"Reverse-mode AD is ideal for functions with many inputs and few outputs, common in neural networks and optimization problems.\n\nusing SHTnsKit\nusing Zygote\n\ncfg = create_gauss_config(16, 16)\n\n# Example: Optimizing spatial field patterns\nfunction loss_function(spatial_field)\n    # Transform to spectral domain\n    sh = analysis(cfg, spatial_field)\n    \n    # Regularize high-frequency components\n    high_freq_penalty = sum(sh[end-20:end].^2)\n    \n    # Target smooth field\n    smooth_penalty = sum(abs2, spatial_field .- mean(spatial_field))\n    \n    return 0.1 * high_freq_penalty + smooth_penalty\nend\n\n# Initial spatial field\nspatial₀ = randn(cfg.nlat, cfg.nlon)\n\n# Compute gradient using Zygote\n∇L = Zygote.gradient(loss_function, spatial₀)[1]\n\n# Update field\nspatial₁ = spatial₀ - 0.01 * ∇L\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Advanced-AD-Patterns","page":"Advanced Usage","title":"Advanced AD Patterns","text":"","category":"section"},{"location":"advanced/#Differentiable-Vector-Field-Operations","page":"Advanced Usage","title":"Differentiable Vector Field Operations","text":"using SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(12, 12)\n\nfunction vector_field_energy(params)\n    n = length(params) ÷ 2\n    S_lm = params[1:n]          # Spheroidal coefficients\n    T_lm = params[n+1:end]      # Toroidal coefficients\n    \n    # Synthesize vector field\n    Vθ, Vφ = synthesize_vector(cfg, S_lm, T_lm)\n    \n    # Compute kinetic energy\n    kinetic_energy = sum(Vθ.^2 + Vφ.^2)\n    \n    # Add enstrophy (related to vorticity)\n    _, T_reconstructed = analyze_vector(cfg, Vθ, Vφ)\n    enstrophy = sum(abs2, T_reconstructed)\n    \n    return 0.5 * kinetic_energy + 0.1 * enstrophy\nend\n\n# Optimize vector field parameters\nnlm = cfg.nlm\nvector_params = randn(2 * nlm)\n\n# Gradient descent\nfor i in 1:10\n    grad = ForwardDiff.gradient(vector_field_energy, vector_params)\n    vector_params .-= 0.01 * grad\n    \n    energy = vector_field_energy(vector_params)\n    println(\"Iteration $i: Energy = $energy\")\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Differentiable-Field-Rotations","page":"Advanced Usage","title":"Differentiable Field Rotations","text":"using SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(16, 16)\n\n# Optimize rotation angles to match target field\nfunction rotation_objective(angles)\n    α, β, γ = angles\n    \n    # Original field\n    # Create bandlimited test coefficients\nsh_original = zeros(cfg.nlm)\nsh_original[1] = 1.0\nif cfg.nlm > 10\n    sh_original[2:5] = [0.5, 0.3, 0.2, 0.1]\nend\n    \n    # Rotate field (in-place helper for real-basis coefficients)\n    sh_rotated = copy(sh_original)\n    rotate_real!(cfg, sh_rotated; alpha=α, beta=β, gamma=γ)\n    \n    # Target field (e.g., aligned with some axis)\n    sh_target = zeros(cfg.nlm)\n    sh_target[1] = 1.0  # Y₀⁰ mode only\n    \n    return sum((sh_rotated - sh_target).^2)\nend\n\n# Find optimal rotation angles\nangles₀ = [0.1, 0.1, 0.1]\n\nfor i in 1:20\n    grad = ForwardDiff.gradient(rotation_objective, angles₀)\n    angles₀ .-= 0.01 * grad\n    \n    obj = rotation_objective(angles₀)\n    println(\"Iteration $i: Objective = $obj, Angles = $angles₀\")\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Neural-Differential-Equations-on-the-Sphere","page":"Advanced Usage","title":"Neural Differential Equations on the Sphere","text":"using SHTnsKit\nusing Zygote\n# using DifferentialEquations  # For ODE solving\n\ncfg = create_gauss_config(20, 20)\n\n# Define a neural ODE on the sphere using SHT\nfunction sphere_neural_ode!(du, u, p, t)\n    # u contains spherical harmonic coefficients\n    # p contains neural network parameters\n    \n    # Transform to spatial domain\n    spatial = synthesize(cfg, u)\n    \n    # Apply nonlinear transformation (neural network layer)\n    # This is a simplified version - real neural networks would be more complex\n    W, b = p[1:length(spatial)], p[length(spatial)+1:end]\n    transformed = tanh.(W .* spatial .+ b[1:size(spatial, 1), 1:size(spatial, 2)])\n    \n    # Transform back to spectral domain for time derivative\n    du .= analysis(cfg, transformed)\nend\n\n# Example usage would involve solving the ODE and differentiating through the solution","category":"section"},{"location":"advanced/#Performance-Considerations-for-AD","page":"Advanced Usage","title":"Performance Considerations for AD","text":"","category":"section"},{"location":"advanced/#Memory-Management","page":"Advanced Usage","title":"Memory Management","text":"using SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(32, 32)\n\n# Pre-allocate buffers to avoid repeated allocation during AD\nstruct ADBuffers\n    sh_buffer::Vector{Float64}\n    spatial_buffer::Matrix{Float64}\n    grad_buffer::Vector{Float64}\nend\n\nfunction create_ad_buffers(cfg)\n    ADBuffers(\n        allocate_spectral(cfg),\n        allocate_spatial(cfg),\n        zeros(cfg.nlm)\n    )\nend\n\nbuffers = create_ad_buffers(cfg)\n\n# Use buffers in AD computations to reduce allocation\nfunction efficient_objective(params, buffers)\n    # Use pre-allocated buffers\n    buffers.sh_buffer[1:length(params)] = params\n    fill!(buffers.sh_buffer, 0.0)\n    buffers.sh_buffer[1:length(params)] = params\n    \n    synthesize!(cfg, buffers.sh_buffer, buffers.spatial_buffer)\n    \n    return sum(abs2, buffers.spatial_buffer)\nend\n\n# This version is more memory efficient\ngrad = ForwardDiff.gradient(p -> efficient_objective(p, buffers), rand(10))\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Choosing-Between-Forward-and-Reverse-Mode","page":"Advanced Usage","title":"Choosing Between Forward and Reverse Mode","text":"using BenchmarkTools\n\n# Rule of thumb:\n# - Use ForwardDiff when: n_parameters < n_outputs\n# - Use Zygote when: n_parameters > n_outputs\n\ncfg = create_gauss_config(16, 16)\nn_params = 50\nn_spatial = cfg.nlat * cfg.nlon\n\nprintln(\"Parameters: $n_params, Spatial points: $n_spatial\")\n\nfunction test_objective(params)\n    sh = zeros(cfg.nlm)\n    sh[1:n_params] = params\n    spatial = synthesis(cfg, sh)\n    return sum(abs2, spatial)  # Single output\nend\n\nparams = rand(n_params)\n\nif n_params < n_spatial\n    println(\"ForwardDiff recommended (fewer parameters than outputs)\")\n    @btime ForwardDiff.gradient($test_objective, $params)\nelse\n    println(\"Zygote recommended (more parameters than outputs)\")\n    @btime Zygote.gradient($test_objective, $params)\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"advanced/#Applications-in-Scientific-Computing","page":"Advanced Usage","title":"Applications in Scientific Computing","text":"","category":"section"},{"location":"advanced/#Inverse-Problems","page":"Advanced Usage","title":"Inverse Problems","text":"# Parameter estimation from observations\nfunction solve_inverse_problem(observations, initial_guess, cfg)\n    using ForwardDiff\n    using Optim\n    \n    function forward_model(params)\n        # Convert parameters to spherical harmonic field\n        sh = param_to_sh(params, cfg)\n        return synthesis(cfg, sh)\n    end\n    \n    function objective(params)\n        predicted = forward_model(params)\n        return sum((observations - predicted).^2)\n    end\n    \n    # Use automatic differentiation for optimization\n    result = optimize(objective, initial_guess, BFGS(), \n                     autodiff=:forward)\n    \n    return result.minimizer\nend","category":"section"},{"location":"advanced/#Data-Assimilation","page":"Advanced Usage","title":"Data Assimilation","text":"# Variational data assimilation with spherical harmonic background\nfunction variational_assimilation(observations, background_sh, obs_locations, cfg)\n    using Zygote\n    \n    function cost_function(analysis_sh)\n        # Background term\n        background_cost = sum((analysis_sh - background_sh).^2)\n        \n        # Observation term\n        analysis_spatial = synthesize(cfg, analysis_sh)\n        obs_cost = sum((analysis_spatial[obs_locations] - observations).^2)\n        \n        return 0.5 * (background_cost + obs_cost)\n    end\n    \n    # Minimize cost function using gradients\n    analysis_sh = copy(background_sh)\n    \n    for i in 1:100\n        grad = Zygote.gradient(cost_function, analysis_sh)[1]\n        analysis_sh .-= 0.01 * grad\n        \n        cost = cost_function(analysis_sh)\n        println(\"Iteration $i: Cost = $cost\")\n        \n        if norm(grad) < 1e-6\n            break\n        end\n    end\n    \n    return analysis_sh\nend\n\nThis comprehensive advanced usage guide demonstrates sophisticated patterns for expert users of SHTnsKit.jl, covering everything from configuration management to large-scale data processing, automatic differentiation, and integration with external scientific computing workflows.","category":"section"},{"location":"grids/#Grid-Types","page":"-","title":"Grid Types","text":"SHTnsKit supports several latitude grids selected via shtns_set_grid flags:\n\nGauss (Gaussian quadrature): Exact for integrals up to degree 2*nlat-1. Use for highest accuracy. Suggested nlat = lmax+1, nphi ≥ 2*mmax+1.\nRegular equiangular without poles (regfast/regdct/quickinit): Midpoint latitudes `θi = (i+0.5)π/nlat. Fast to set up and compatible with FFT-friendly sampling. Weightswi = (π/nlat) sin(θi)` approximate the integral.\nRegular equiangular with poles (regpoles): `θi = i π/(nlat-1)including poles. Weights arewi = (π/(nlat-1)) sin(θi)`.\n\nUse shtns_set_grid_auto to get suggested nlat/nphi depending on grid type. For best numerical exactness, prefer Gauss. For speed and compatibility with standard image-like sampling, prefer regular grids with precomputed Legendre tables via prepare_plm_tables!(cfg).","category":"section"},{"location":"examples/#Examples-Gallery","page":"Examples Gallery","title":"Examples Gallery","text":"<div style=\"background: linear-gradient(135deg, #059669 0%, #10b981 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">Examples Gallery</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Real-world examples and tutorials from beginner to advanced</p>\n</div>\n\nReal-world examples and tutorials demonstrating SHTnsKit.jl capabilities, organized by difficulty level.\n\n<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0;\">\n\n<div style=\"background: #eff6ff; border-radius: 8px; padding: 1rem; border-left: 4px solid #2563eb;\">\n    <strong style=\"color: #1e40af;\">Beginner</strong>\n    <p style=\"margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #475569;\">\n        Start here if you're new to spherical harmonics\n    </p>\n</div>\n\n<div style=\"background: #fef3c7; border-radius: 8px; padding: 1rem; border-left: 4px solid #f59e0b;\">\n    <strong style=\"color: #92400e;\">Intermediate</strong>\n    <p style=\"margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #475569;\">\n        For users comfortable with basic transforms\n    </p>\n</div>\n\n<div style=\"background: #f3e8ff; border-radius: 8px; padding: 1rem; border-left: 4px solid #7c3aed;\">\n    <strong style=\"color: #5b21b6;\">Advanced</strong>\n    <p style=\"margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #475569;\">\n        Complex workflows and specialized applications\n    </p>\n</div>\n\n</div>\n\ntip: Learning Path\nWork through the examples in order for the best learning experience.","category":"section"},{"location":"examples/#Beginner-Examples","page":"Examples Gallery","title":"Beginner Examples","text":"Start here if you're new to spherical harmonics. These examples teach fundamental concepts with simple, well-explained code.","category":"section"},{"location":"examples/#Example-1:-Your-First-Transform","page":"Examples Gallery","title":"Example 1: Your First Transform","text":"Goal: Learn the basic workflow of spherical harmonic transforms\n\nusing SHTnsKit\n\n# Step 1: Create a configuration (like setting up your workspace)\nlmax = 16\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\nprintln(\"Created configuration for degree up to $lmax\")\n\n# Step 2: Create a simple temperature pattern\n# Simple pattern: warm equator, cold poles (Y_2^0 harmonic)\ntemperature = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat\n    x = cfg.x[i]  # cos(θ) at this latitude\n    temperature[i, :] .= 273.15 + 30 * (1 - x^2)  # Warmer at equator\nend\n\nprintln(\"Temperature range: $(extrema(temperature)) K\")\n\n# Step 3: Transform to spherical harmonic coefficients (analysis)\nAlm = analysis(cfg, temperature)\nprintln(\"Coefficient matrix size: $(size(Alm))\")\n\n# Step 4: Find the most important coefficient (skip l=0 global mean)\nmax_val, max_idx = findmax(abs.(Alm[2:end, :]))\nprintln(\"Largest non-constant mode magnitude: $max_val\")\n\n# Step 5: Reconstruct the original field (synthesis)\nT_reconstructed = synthesis(cfg, Alm)\nerror = maximum(abs.(temperature - T_reconstructed))\nprintln(\"Reconstruction error: $error (should be tiny!)\")\n\ndestroy_config(cfg)\n\nKey concepts learned:\n\nConfiguration setup (create_gauss_config)\nCreating realistic data patterns\nAnalysis: spatial → spectral (analysis)\nSynthesis: spectral → spatial (synthesis)\nUnderstanding (l,m) mode indices","category":"section"},{"location":"examples/#Example-2:-Pure-Spherical-Harmonic-Patterns","page":"Examples Gallery","title":"Example 2: Pure Spherical Harmonic Patterns","text":"Goal: Understand how individual spherical harmonic modes look\n\nusing SHTnsKit\n\nlmax = 32\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n# Create pure Y_2^0 spherical harmonic (zonal mode)\n# Coefficients are stored as (lmax+1) × (mmax+1) matrix\nAlm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nAlm[3, 1] = 1.0  # l=2, m=0 (index is l+1 for row, m+1 for column)\nprintln(\"Creating Y₂⁰ pattern (zonal, m=0)\")\n\n# Synthesize to spatial domain\nY20_pattern = synthesis(cfg, Alm)\n\n# This creates a pattern that varies only with latitude\nprintln(\"Pattern statistics:\")\nprintln(\"  Min value: $(minimum(Y20_pattern))\")\nprintln(\"  Max value: $(maximum(Y20_pattern))\")\nprintln(\"  At north pole: $(Y20_pattern[1,1])\")\nprintln(\"  At equator: $(Y20_pattern[div(cfg.nlat,2),1])\")\n\n# The Y_2^0 pattern = (3cos²θ - 1)/2\n# Positive at poles, negative at equator\n\ndestroy_config(cfg)\n\nKey concepts learned:\n\nHow to create pure spherical harmonic patterns\nUnderstanding zonal (m=0) vs sectoral (m≠0) modes\nThe relationship between (l,m) indices and spatial patterns\nCoefficient indexing: Alm[l+1, m+1]\n\nTry this: Change to Alm[3, 3] = 1.0 (l=2, m=2) to see a sectoral pattern!","category":"section"},{"location":"examples/#Example-3:-Understanding-Power-Spectra","page":"Examples Gallery","title":"Example 3: Understanding Power Spectra","text":"Goal: Learn how energy is distributed across different spatial scales\n\nusing SHTnsKit\n\nlmax = 32\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n# Create a field with multiple scales (like weather patterns)\nfield = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    field[i,j] = 2*sin(2*θ)*cos(φ) +      # Large scale\n                 0.5*sin(6*θ)*cos(3*φ) +   # Medium scale\n                 0.1*sin(12*θ)*cos(6*φ)    # Small scale\nend\n\nprintln(\"Created multi-scale field with 3 different spatial scales\")\n\n# Transform to spectral domain\nAlm = analysis(cfg, field)\n\n# Compute power spectrum using energy_scalar_l_spectrum\npower = energy_scalar_l_spectrum(cfg, Alm)\n\n# Find which scales dominate\nmax_power_degree = argmax(power[2:end])  # Skip l=0 (global mean)\nprintln(\"Peak energy at degree l = $max_power_degree\")\nprintln(\"This corresponds to ~$(360/max_power_degree)° wavelength\")\n\n# Print first few power values\nprintln(\"Power spectrum (first 10 degrees):\")\nfor l in 0:min(9, length(power)-1)\n    println(\"  l=$l: $(power[l+1])\")\nend\n\ndestroy_config(cfg)\n\nKey concepts learned:\n\nHow to create multi-scale patterns\nPower spectrum analysis shows energy distribution\nRelationship between degree l and spatial wavelength\nUse energy_scalar_l_spectrum for power spectrum analysis\n\nPhysical meaning: In meteorology, this tells you whether your weather system is dominated by large-scale patterns (like jet streams) or small-scale features (like thunderstorms).","category":"section"},{"location":"examples/#Intermediate-Examples","page":"Examples Gallery","title":"Intermediate Examples","text":"Ready to tackle more complex problems? These examples introduce vector fields, real-world data patterns, and scientific applications.","category":"section"},{"location":"examples/#Vector-Field-Decomposition","page":"Examples Gallery","title":"Vector Field Decomposition","text":"","category":"section"},{"location":"examples/#Vorticity-Divergence-Decomposition","page":"Examples Gallery","title":"Vorticity-Divergence Decomposition","text":"using SHTnsKit\nusing LinearAlgebra\n\nlmax = 64\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n# Create a realistic atmospheric flow pattern\nu = zeros(cfg.nlat, cfg.nlon)  # Zonal wind (east-west)\nv = zeros(cfg.nlat, cfg.nlon)  # Meridional wind (north-south)\n\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    u[i,j] = 20 * sin(2θ) * (1 + 0.4 * cos(4φ))  # Jet stream\n    v[i,j] = 5 * cos(3θ) * sin(2φ)                # Meridional flow\nend\n\n# Decompose into spheroidal (divergent) and toroidal (rotational)\nSlm, Tlm = spat_to_SHsphtor(cfg, u, v)\n\n# Analyze energy distribution\nspheroidal_energy = sum(abs2, Slm)\ntoroidal_energy = sum(abs2, Tlm)\nprintln(\"Spheroidal (divergent) energy: $spheroidal_energy\")\nprintln(\"Toroidal (rotational) energy: $toroidal_energy\")\n\n# Reconstruct original velocity\nu_recon, v_recon = SHsphtor_to_spat(cfg, Slm, Tlm)\nvelocity_error = norm(u - u_recon) + norm(v - v_recon)\nprintln(\"Velocity reconstruction error: $velocity_error\")\n\ndestroy_config(cfg)","category":"section"},{"location":"examples/#Stream-Function-from-Vorticity","page":"Examples Gallery","title":"Stream Function from Vorticity","text":"using SHTnsKit\nusing LinearAlgebra\n\nlmax = 48\ncfg = create_gauss_config(lmax, lmax+2; nlon=2*lmax+1)\n\n# Create vorticity field (e.g., from observations)\nvorticity = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    vorticity[i,j] = exp(-((θ - π/2)^2 + (φ - π)^2) / 0.5^2) * sin(4φ)\nend\n\n# Transform vorticity to spectral domain\nζ_lm = analysis(cfg, vorticity)\n\n# Solve ∇²ψ = ζ for stream function ψ\n# In spectral domain: -l(l+1) ψ_lm = ζ_lm\nψ_lm = similar(ζ_lm)\nfor l in 0:cfg.lmax\n    for m in 0:min(l, cfg.mmax)\n        if l > 0\n            ψ_lm[l+1, m+1] = -ζ_lm[l+1, m+1] / (l * (l + 1))\n        else\n            ψ_lm[l+1, m+1] = 0.0  # l=0 mode: constant not uniquely determined\n        end\n    end\nend\n\n# Get velocity from stream function (toroidal component only)\nSlm_zero = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nu_stream, v_stream = SHsphtor_to_spat(cfg, Slm_zero, ψ_lm)\n\n# Convert stream function to spatial domain\nstream_function = synthesis(cfg, ψ_lm)\n\nprintln(\"Stream function range: \", extrema(stream_function))\nprintln(\"Max velocity from stream: \", maximum(sqrt.(u_stream.^2 .+ v_stream.^2)))\n\ndestroy_config(cfg)","category":"section"},{"location":"examples/#Parallel-Computing-Examples","page":"Examples Gallery","title":"Parallel Computing Examples","text":"","category":"section"},{"location":"examples/#MPI-Distributed-Computing","page":"Examples Gallery","title":"MPI Distributed Computing","text":"Goal: Learn how to use MPI for large-scale parallel spherical harmonic computations\n\n# Save as parallel_example.jl and run with: mpiexec -n 4 julia parallel_example.jl\nusing MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\nnprocs = MPI.Comm_size(comm)\n\nif rank == 0\n    println(\"Running SHTnsKit parallel example with $nprocs processes\")\nend\n\n# Create configuration (same on all processes)\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\nif rank == 0\n    println(\"Problem size: $(cfg.nlm) spectral coefficients\")\n    println(\"Grid: $(cfg.nlat) × $(cfg.nlon) spatial points\")\nend\n\n# Create distributed array using PencilArrays\npen = Pencil((nlat, nlon), comm)\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test data (Y_2^0 pattern)\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    x = cfg.x[i_global]\n    for j in 1:length(ranges[2])\n        fθφ[i_local, j] = (3*x^2 - 1)/2\n    end\nend\n\n# Benchmark parallel transforms\nMPI.Barrier(comm)\nstart_time = MPI.Wtime()\n\nn_iter = 50\nfor i in 1:n_iter\n    Alm = SHTnsKit.dist_analysis(cfg, fθφ)\n    fθφ_out = SHTnsKit.dist_synthesis(cfg, Alm; prototype_θφ=fθφ, real_output=true)\nend\n\nMPI.Barrier(comm)\nend_time = MPI.Wtime()\n\nif rank == 0\n    avg_time = (end_time - start_time) / n_iter\n    println(\"Parallel roundtrip: $(avg_time*1000) ms per iteration\")\nend\n\n# Verify accuracy\nAlm = SHTnsKit.dist_analysis(cfg, fθφ)\nfθφ_recovered = SHTnsKit.dist_synthesis(cfg, Alm; prototype_θφ=fθφ, real_output=true)\n\nmax_err = maximum(abs.(parent(fθφ_recovered) .- parent(fθφ)))\nglobal_max_err = MPI.Allreduce(max_err, MPI.MAX, comm)\n\nif rank == 0\n    println(\"Roundtrip error: $global_max_err\")\n    println(global_max_err < 1e-10 ? \"SUCCESS!\" : \"FAILED\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()\n\nKey concepts:\n\nMPI initialization and communicator setup\nPencilArrays for domain decomposition\nDistributed transforms with dist_analysis and dist_synthesis\nError verification across MPI ranks","category":"section"},{"location":"examples/#Run-Example-Scripts","page":"Examples Gallery","title":"Run Example Scripts","text":"# Per-rank SHT scalar roundtrip (safe PencilArrays allocation)\nmpiexec -n 2 julia --project=. examples/parallel_roundtrip.jl\n\n# Distributed FFT roundtrip along φ using PencilFFTs\nmpiexec -n 2 julia --project=. examples/parallel_fft_roundtrip.jl","category":"section"},{"location":"examples/#Single-Node-Performance-Example","page":"Examples Gallery","title":"Single-Node Performance Example","text":"Goal: Benchmark and optimize single-node performance\n\nusing SHTnsKit, BenchmarkTools\n\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\nprintln(\"Single-Node Performance Benchmark\")\nprintln(\"=\"^40)\nprintln(\"Grid size: $(cfg.nlat) × $(cfg.nlon)\")\nprintln(\"Spectral coefficients: $(cfg.nlm)\")\n\n# Create test data\nspatial = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    spatial[i,j] = sin(2θ) * cos(φ) + 0.5 * sin(4θ) * cos(3φ)\nend\n\n# Benchmark analysis (spatial → spectral)\nanalysis_time = @belapsed analysis($cfg, $spatial)\nprintln(\"Analysis time: $(analysis_time*1000) ms\")\n\nAlm = analysis(cfg, spatial)\n\n# Benchmark synthesis (spectral → spatial)\nsynthesis_time = @belapsed synthesis($cfg, $Alm)\nprintln(\"Synthesis time: $(synthesis_time*1000) ms\")\n\n# Benchmark roundtrip\nroundtrip_time = @belapsed begin\n    alm = analysis($cfg, $spatial)\n    synthesis($cfg, alm)\nend\nprintln(\"Roundtrip time: $(roundtrip_time*1000) ms\")\n\n# Verify accuracy\nrecovered = synthesis(cfg, Alm)\nmax_error = maximum(abs.(spatial - recovered))\nprintln(\"Roundtrip error: $max_error\")\n\n# Threading info\nprintln(\"\\nThreading configuration:\")\nprintln(\"  Julia threads: $(Threads.nthreads())\")\n\ndestroy_config(cfg)\n\nKey concepts:\n\nPerformance benchmarking with BenchmarkTools\nForward and inverse transform timing\nAccuracy verification","category":"section"},{"location":"examples/#Parallel-Vector-Transform-Example","page":"Examples Gallery","title":"Parallel Vector Transform Example","text":"Goal: Perform distributed vector field transforms\n\n# Save as parallel_vector.jl, run with: mpiexec -n 4 julia parallel_vector.jl\nusing MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\nnprocs = MPI.Comm_size(comm)\n\n# Create configuration\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\nif rank == 0\n    println(\"Parallel Vector Transform Example\")\n    println(\"Problem: $(cfg.nlm) coefficients, $(cfg.nlat)×$(cfg.nlon) grid\")\n    println(\"MPI processes: $nprocs\")\nend\n\n# Create distributed arrays for velocity field\npen = Pencil((nlat, nlon), comm)\nVθ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\nVφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test vector field (solid body rotation)\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    θ = cfg.θ[i_global]\n    for (j_local, j_global) in enumerate(ranges[2])\n        φ = cfg.φ[j_global]\n        Vθ[i_local, j_local] = cos(θ) * sin(φ)\n        Vφ[i_local, j_local] = cos(φ)\n    end\nend\n\n# Benchmark distributed vector transforms\nMPI.Barrier(comm)\nstart_time = MPI.Wtime()\n\nn_iter = 20\nfor i in 1:n_iter\n    Slm, Tlm = SHTnsKit.dist_spat_to_SHsphtor(cfg, Vθ, Vφ)\n    Vθ_out, Vφ_out = SHTnsKit.dist_SHsphtor_to_spat(cfg, Slm, Tlm; prototype_θφ=Vθ)\nend\n\nMPI.Barrier(comm)\nend_time = MPI.Wtime()\n\nif rank == 0\n    avg_time = (end_time - start_time) / n_iter\n    println(\"Vector roundtrip: $(avg_time*1000) ms per iteration\")\nend\n\n# Verify accuracy\nSlm, Tlm = SHTnsKit.dist_spat_to_SHsphtor(cfg, Vθ, Vφ)\nVθ_rec, Vφ_rec = SHTnsKit.dist_SHsphtor_to_spat(cfg, Slm, Tlm; prototype_θφ=Vθ)\n\nθ_err = maximum(abs.(parent(Vθ_rec) .- parent(Vθ)))\nφ_err = maximum(abs.(parent(Vφ_rec) .- parent(Vφ)))\nglobal_θ_err = MPI.Allreduce(θ_err, MPI.MAX, comm)\nglobal_φ_err = MPI.Allreduce(φ_err, MPI.MAX, comm)\n\nif rank == 0\n    println(\"Vθ roundtrip error: $global_θ_err\")\n    println(\"Vφ roundtrip error: $global_φ_err\")\n    println((global_θ_err < 1e-10 && global_φ_err < 1e-10) ? \"SUCCESS!\" : \"FAILED\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()","category":"section"},{"location":"examples/#Scaling-Test-Example","page":"Examples Gallery","title":"Scaling Test Example","text":"Goal: Test parallel scaling with different process counts\n\n# Save as scaling_test.jl, run with: mpiexec -n 4 julia scaling_test.jl\nusing MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\nnprocs = MPI.Comm_size(comm)\n\nif rank == 0\n    println(\"Parallel Scaling Test\")\n    println(\"MPI processes: $nprocs\")\nend\n\n# Test different problem sizes\nfor lmax in [32, 64, 128]\n    nlat = lmax + 2\n    nlon = 2*lmax + 1\n    cfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n    # Create distributed array\n    pen = Pencil((nlat, nlon), comm)\n    fθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n    # Fill with test data\n    ranges = PencilArrays.range_local(pen)\n    for (i_local, i_global) in enumerate(ranges[1])\n        x = cfg.x[i_global]\n        for j in 1:length(ranges[2])\n            fθφ[i_local, j] = (3*x^2 - 1)/2\n        end\n    end\n\n    # Warmup\n    for _ in 1:5\n        Alm = SHTnsKit.dist_analysis(cfg, fθφ)\n        SHTnsKit.dist_synthesis(cfg, Alm; prototype_θφ=fθφ, real_output=true)\n    end\n\n    # Benchmark\n    MPI.Barrier(comm)\n    start_time = MPI.Wtime()\n\n    n_iter = 50\n    for _ in 1:n_iter\n        Alm = SHTnsKit.dist_analysis(cfg, fθφ)\n        SHTnsKit.dist_synthesis(cfg, Alm; prototype_θφ=fθφ, real_output=true)\n    end\n\n    MPI.Barrier(comm)\n    end_time = MPI.Wtime()\n\n    if rank == 0\n        avg_time = (end_time - start_time) / n_iter * 1000\n        println(\"lmax=$lmax: $(round(avg_time, digits=2)) ms/roundtrip\")\n    end\n\n    destroy_config(cfg)\nend\n\nMPI.Finalize()\n\nKey concepts:\n\nTesting performance across problem sizes\nProper warmup before timing\nParallel synchronization for accurate timing","category":"section"},{"location":"examples/#Advanced-Applications","page":"Examples Gallery","title":"Advanced Applications","text":"","category":"section"},{"location":"examples/#Multiscale-Analysis","page":"Examples Gallery","title":"Multiscale Analysis","text":"using SHTnsKit\n\n# Create different resolution configurations\nlmax_values = [16, 32, 64, 128]\ncfgs = []\nfor lmax in lmax_values\n    nlat = lmax + 2\n    nlon = 2*lmax + 1\n    push!(cfgs, create_gauss_config(lmax, nlat; nlon=nlon))\nend\n\n# Use highest resolution for reference field\ncfg_hi = cfgs[end]\n\n# Create test field with multiple scales at highest resolution\nfield = zeros(cfg_hi.nlat, cfg_hi.nlon)\nfor i in 1:cfg_hi.nlat, j in 1:cfg_hi.nlon\n    θ = cfg_hi.θ[i]\n    φ = cfg_hi.φ[j]\n    field[i,j] = sin(2θ) * cos(φ) +           # Large scale\n                 0.3 * sin(8θ) * cos(4φ) +     # Medium scale\n                 0.1 * sin(16θ) * cos(8φ)      # Small scale\nend\n\n# Analyze at different resolutions\npowers = []\nfor cfg in cfgs\n    # Create field at this resolution\n    field_i = zeros(cfg.nlat, cfg.nlon)\n    for i in 1:cfg.nlat, j in 1:cfg.nlon\n        θ = cfg.θ[i]\n        φ = cfg.φ[j]\n        field_i[i,j] = sin(2θ) * cos(φ) +\n                       0.3 * sin(8θ) * cos(4φ) +\n                       0.1 * sin(16θ) * cos(8φ)\n    end\n\n    # Analyze and compute power spectrum\n    f_lm = analysis(cfg, field_i)\n    power_i = energy_scalar_l_spectrum(cfg, f_lm)\n    push!(powers, power_i)\n\n    println(\"Resolution lmax=$(cfg.lmax): $(length(power_i)) modes\")\nend\n\n# Compare power spectra at common degrees\nprintln(\"\\nPower at l=2 (large scale):\")\nfor (i, cfg) in enumerate(cfgs)\n    println(\"  lmax=$(cfg.lmax): $(powers[i][3])\")\nend\n\n# Cleanup\nfor cfg in cfgs\n    destroy_config(cfg)\nend","category":"section"},{"location":"examples/#Field-Rotation-and-Coordinate-Transformations","page":"Examples Gallery","title":"Field Rotation and Coordinate Transformations","text":"using SHTnsKit\n\nlmax = 32\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create field in one coordinate system\noriginal_field = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = cfg.θ[i]\n    φ = cfg.φ[j]\n    original_field[i,j] = sin(3θ) * cos(2φ)\nend\n\n# Transform to spectral domain\nf_lm = analysis(cfg, original_field)\n\n# Rotate using Euler angles (ZYZ convention)\nα, β, γ = π/4, π/6, π/8\nf_rot = copy(f_lm)\nrotate_real!(cfg, f_rot; alpha=α, beta=β, gamma=γ)\n\n# Transform back to spatial domain\nrotated_field = synthesis(cfg, f_rot)\n\nprintln(\"Original field range: \", extrema(original_field))\nprintln(\"Rotated field range: \", extrema(rotated_field))\n\n# Verify rotation preserves power\norig_power = sum(abs2, f_lm)\nrot_power = sum(abs2, f_rot)\nprintln(\"Power preserved: \", isapprox(orig_power, rot_power, rtol=1e-10))\n\ndestroy_config(cfg)","category":"section"},{"location":"examples/#High-Performance-Examples","page":"Examples Gallery","title":"High-Performance Examples","text":"","category":"section"},{"location":"examples/#Multi-threaded-Batch-Processing","page":"Examples Gallery","title":"Multi-threaded Batch Processing","text":"using SHTnsKit\nusing Base.Threads\nusing Statistics\n\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Large batch of fields to process\nn_batch = 100\n# Create bandlimited test fields (smooth functions prevent errors)\ninput_fields = []\nfor i in 1:n_batch\n    field = zeros(cfg.nlat, cfg.nlon)\n    for j in 1:cfg.nlat, k in 1:cfg.nlon\n        θ = cfg.θ[j]\n        φ = cfg.φ[k]\n        field[j,k] = 1.0 + 0.3 * sin(2θ) * cos(φ) * (1 + 0.1*sin(i))\n    end\n    push!(input_fields, field)\nend\n\n# Process with threading\nprintln(\"Processing $n_batch fields with $(nthreads()) Julia threads...\")\nresults = Vector{Float64}(undef, n_batch)\n\n@time @threads for i in 1:n_batch\n    # Each thread gets its own work\n    field = input_fields[i]\n\n    # Transform and compute power spectrum\n    sh = analysis(cfg, field)\n    power = energy_scalar_l_spectrum(cfg, sh)\n\n    # Store result (total energy)\n    results[i] = sum(power)\nend\n\nprintln(\"Mean energy per field: \", mean(results))\nprintln(\"Energy std dev: \", std(results))\n\ndestroy_config(cfg)","category":"section"},{"location":"examples/#Validation-and-Testing-Examples","page":"Examples Gallery","title":"Validation and Testing Examples","text":"","category":"section"},{"location":"examples/#Analytical-Test-Cases","page":"Examples Gallery","title":"Analytical Test Cases","text":"using SHTnsKit\n\nlmax = 24\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Test pure spherical harmonics Y_l^m\n# For simplicity, test real zonal harmonics (m=0)\ntest_cases = [\n    (l=0, m=0, desc=\"Y₀⁰ (constant)\"),\n    (l=1, m=0, desc=\"Y₁⁰ (dipole)\"),\n    (l=2, m=0, desc=\"Y₂⁰ (quadrupole)\"),\n]\n\nprintln(\"Analytical validation tests:\")\nfor case in test_cases\n    # Create spectral coefficients with single mode\n    Alm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Alm[case.l+1, case.m+1] = 1.0\n\n    # Synthesize to spatial domain\n    spatial = synthesis(cfg, Alm)\n\n    # Analyze back to spectral\n    recovered = analysis(cfg, spatial)\n\n    # Check coefficient at expected location\n    coeff_val = recovered[case.l+1, case.m+1]\n\n    # Find largest coefficient magnitude\n    max_val, max_idx = findmax(abs.(recovered))\n\n    println(\"Test: $(case.desc)\")\n    println(\"  Expected: l=$(case.l), m=$(case.m)\")\n    println(\"  Recovered coefficient: $coeff_val\")\n    println(\"  Max magnitude at: $(Tuple(max_idx)) = $max_val\")\n\n    # Check if roundtrip preserves the mode\n    is_correct = max_idx == CartesianIndex(case.l+1, case.m+1)\n    println(\"  Result: \", is_correct ? \"PASS\" : \"FAIL\")\n    println()\nend\n\ndestroy_config(cfg)","category":"section"},{"location":"examples/#Numerical-Accuracy-Tests","page":"Examples Gallery","title":"Numerical Accuracy Tests","text":"using SHTnsKit\nusing LinearAlgebra\n\n# Test different resolutions\nresolutions = [16, 32, 64]\n\nprintln(\"Accuracy vs Resolution Test:\")\nprintln(\"=\" ^ 40)\n\nfor lmax in resolutions\n    nlat = lmax + 2\n    nlon = 2*lmax + 1\n    cfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n    # Create bandlimited test coefficients (prevents roundtrip errors)\n    Alm_original = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n    Alm_original[1, 1] = 1.0  # l=0, m=0\n    Alm_original[3, 1] = 0.5  # l=2, m=0\n    if cfg.lmax >= 4\n        Alm_original[5, 1] = 0.2  # l=4, m=0\n    end\n\n    # Round-trip transform\n    spatial = synthesis(cfg, Alm_original)\n    Alm_recovered = analysis(cfg, spatial)\n\n    # Measure error\n    error = norm(Alm_original - Alm_recovered) / norm(Alm_original)\n\n    println(\"lmax=$lmax: relative error = $(round(error, sigdigits=3))\")\n\n    destroy_config(cfg)\nend\n\n# Test with complex pattern (non-zonal modes)\nprintln(\"\\nNon-zonal mode test:\")\nlmax = 32\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\nAlm_original = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nAlm_original[3, 3] = 1.0 + 0.5im  # l=2, m=2\n\nspatial = synthesis(cfg, Alm_original)\nAlm_recovered = analysis(cfg, spatial)\n\nerror = norm(Alm_original - Alm_recovered) / norm(Alm_original)\nprintln(\"l=2, m=2 roundtrip error: $(round(error, sigdigits=3))\")\n\ndestroy_config(cfg)\n\nThese examples demonstrate the full range of SHTnsKit.jl capabilities from basic transforms to advanced scientific applications. Each example can serve as a starting point for your specific research needs.","category":"section"},{"location":"mpi_roundtrip/#Distributed-Round-trip-Example-(MPI)","page":"-","title":"Distributed Round-trip Example (MPI)","text":"This sketch shows how to run a distributed scalar round-trip using PencilArrays and PencilFFTs. It assumes you have constructed a (θ,φ) prototype PencilArray on your MPI communicator.\n\nusing MPI, PencilArrays, PencilFFTs, SHTnsKit\n\nMPI.Init()\ncomm = COMM_WORLD\n\n# Build config and prototype (θ,φ) pencil\ncfg = create_gauss_config(32, 40; nlon=65)\n\n# Assume you created a prototype `(θ,φ)` pencil named proto_θφ.\n# For example (API depends on your PencilArrays version):\n# proto_θφ = allocate(comm; dims=(:θ,:φ), sizes=(cfg.nlat, cfg.nlon), eltype=Float64)\n\n# Fill a test field\nfθφ = similar(proto_θφ)\nforeachindex(fθφ) do I\n    fθφ[I] = rand()\nend\n\n# Distributed analysis -> Alm (dense for now)\nAlm = dist_analysis(cfg, fθφ)\n\n# Distributed synthesis using prototype\nfθφ_out = dist_synthesis(cfg, Alm; prototype_θφ=fθφ)\n\n# Compute local/global relative errors\nrel_local, rel_global = dist_scalar_roundtrip!(cfg, fθφ)\nif Comm_rank(comm) == 0\n    @info \"Scalar round-trip rel error\" rel_local rel_global\nend\n\nMPI.Finalize()\n\nFor vector fields, use dist_spat_to_SHsphtor and dist_SHsphtor_to_spat with the same prototype_θφ. Precomputing Legendre tables via prepare_plm_tables!(cfg) on regular grids typically improves performance.","category":"section"},{"location":"distributed/#Distributed-Computing","page":"Distributed Computing","title":"Distributed Computing","text":"<div style=\"background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">MPI Parallelization</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Scale your transforms across thousands of cores with PencilArrays</p>\n</div>\n\nSHTnsKit.jl integrates seamlessly with MPI through PencilArrays.jl for distributed memory parallelization. This enables scaling spherical harmonic transforms to large HPC clusters.\n\ntip: When to Use Distributed Computing\nMPI parallelization is most beneficial for large problems (lmax > 128) or when processing many fields simultaneously. For single-field transforms on smaller problems, consider GPU acceleration instead.\n\n","category":"section"},{"location":"distributed/#Quick-Start","page":"Distributed Computing","title":"Quick Start","text":"using MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\n# Configuration\nlmax = 64\nnlat = lmax + 2\nnlon = 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed array\ncomm = MPI.COMM_WORLD\npen = Pencil((nlat, nlon), comm)\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test data (Y_2^0 pattern)\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    x = cfg.x[i_global]\n    for j in 1:length(ranges[2])\n        fθφ[i_local, j] = (3*x^2 - 1)/2\n    end\nend\n\n# Distributed transforms\nAlm = SHTnsKit.dist_analysis(cfg, fθφ)\nfθφ_recovered = SHTnsKit.dist_synthesis(cfg, Alm; prototype_θφ=fθφ, real_output=true)\n\n# Verify\nmax_err = maximum(abs.(parent(fθφ_recovered) .- parent(fθφ)))\nglobal_max_err = MPI.Allreduce(max_err, MPI.MAX, comm)\n\nif MPI.Comm_rank(comm) == 0\n    println(\"Roundtrip error: $global_max_err\")\nend\n\ndestroy_config(cfg)\nMPI.Finalize()\n\n","category":"section"},{"location":"distributed/#Installation","page":"Distributed Computing","title":"Installation","text":"","category":"section"},{"location":"distributed/#Requirements","page":"Distributed Computing","title":"Requirements","text":"Julia 1.10+\nMPI library (OpenMPI or MPICH)\nPencilArrays.jl and PencilFFTs.jl","category":"section"},{"location":"distributed/#Setup","page":"Distributed Computing","title":"Setup","text":"Linux (Ubuntu/Debian):\n\nsudo apt-get install libopenmpi-dev openmpi-bin\n\nmacOS:\n\nbrew install open-mpi\n\nJulia packages:\n\nusing Pkg\nPkg.add([\"MPI\", \"PencilArrays\", \"PencilFFTs\"])\n\n","category":"section"},{"location":"distributed/#API-Reference","page":"Distributed Computing","title":"API Reference","text":"","category":"section"},{"location":"distributed/#Distributed-Transforms","page":"Distributed Computing","title":"Distributed Transforms","text":"Function Description\ndist_analysis(cfg, fθφ) Distributed spatial → spectral transform\ndist_synthesis(cfg, Alm; prototype_θφ) Distributed spectral → spatial transform\ndist_spat_to_SHsphtor(cfg, Vθ, Vφ) Distributed vector field analysis\ndist_SHsphtor_to_spat(cfg, Slm, Tlm; prototype_θφ) Distributed vector field synthesis","category":"section"},{"location":"distributed/#Spectral-Operators","page":"Distributed Computing","title":"Spectral Operators","text":"Function Description\ndist_scalar_laplacian(cfg, fθφ) Distributed Laplacian computation\ndist_spatial_divergence(cfg, Vθ, Vφ) Distributed divergence\ndist_spatial_vorticity(cfg, Vθ, Vφ) Distributed vorticity\n\n","category":"section"},{"location":"distributed/#Running-MPI-Programs","page":"Distributed Computing","title":"Running MPI Programs","text":"Save your script as transform_mpi.jl and run with:\n\nmpiexec -n 4 julia --project transform_mpi.jl\n\n","category":"section"},{"location":"distributed/#Working-with-PencilArrays","page":"Distributed Computing","title":"Working with PencilArrays","text":"","category":"section"},{"location":"distributed/#Understanding-Domain-Decomposition","page":"Distributed Computing","title":"Understanding Domain Decomposition","text":"PencilArrays distributes data across MPI ranks by splitting along one or more dimensions:\n\nusing MPI, PencilArrays\n\nMPI.Init()\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\n\n# Create pencil decomposition\npen = Pencil((nlat, nlon), comm)\n\n# Each rank owns a portion of the data\nlocal_size = PencilArrays.size_local(pen)\nglobal_range = PencilArrays.range_local(pen)\n\nprintln(\"Rank $rank: local size = $local_size, global range = $global_range\")","category":"section"},{"location":"distributed/#Accessing-Local-Data","page":"Distributed Computing","title":"Accessing Local Data","text":"# Create distributed array\nfθφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Access local data directly\nlocal_data = parent(fθφ)\n\n# Use local_range() helper from SHTnsKit\nfor idx in local_range(fθφ)\n    local_data[idx] = some_value\nend\n\n","category":"section"},{"location":"distributed/#Vector-Field-Transforms","page":"Distributed Computing","title":"Vector Field Transforms","text":"using MPI\nMPI.Init()\n\nusing SHTnsKit, PencilArrays, PencilFFTs\n\ncomm = MPI.COMM_WORLD\nlmax = 64\nnlat, nlon = lmax + 2, 2*lmax + 1\ncfg = create_gauss_config(lmax, nlat; nlon=nlon)\n\n# Create distributed vector field components\npen = Pencil((nlat, nlon), comm)\nVθ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\nVφ = PencilArray(pen, zeros(Float64, PencilArrays.size_local(pen)...))\n\n# Fill with test data\nranges = PencilArrays.range_local(pen)\nfor (i_local, i_global) in enumerate(ranges[1])\n    θ = cfg.θ[i_global]\n    for (j_local, j_global) in enumerate(ranges[2])\n        φ = cfg.φ[j_global]\n        Vθ[i_local, j_local] = cos(θ) * sin(φ)\n        Vφ[i_local, j_local] = cos(φ)\n    end\nend\n\n# Distributed vector transform\nSlm, Tlm = SHTnsKit.dist_spat_to_SHsphtor(cfg, Vθ, Vφ)\nVθ_out, Vφ_out = SHTnsKit.dist_SHsphtor_to_spat(cfg, Slm, Tlm; prototype_θφ=Vθ)\n\ndestroy_config(cfg)\nMPI.Finalize()\n\n","category":"section"},{"location":"distributed/#Best-Practices","page":"Distributed Computing","title":"Best Practices","text":"note: Performance Tips\nProblem size: MPI overhead is significant for small problems. Use lmax > 64 for benefit.\nProcess count: Scale processes with problem size. Too many processes hurt efficiency.\nMemory: Each rank needs memory for local data plus communication buffers.\nI/O: Use parallel I/O (HDF5, NetCDF) for large datasets.\n\n","category":"section"},{"location":"distributed/#See-Also","page":"Distributed Computing","title":"See Also","text":"GPU Acceleration - Single-node GPU speedup\nPerformance Guide - Optimization strategies\nAPI Reference - Complete function documentation","category":"section"},{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start","title":"Quick Start Guide","text":"<div style=\"background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">Get Started in 5 Minutes</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">From installation to your first spherical harmonic transform</p>\n</div>\n\nGet up and running with SHTnsKit.jl in minutes. This guide covers the essential concepts and common workflows.\n\n","category":"section"},{"location":"quickstart/#Installation","page":"Quick Start","title":"Installation","text":"using Pkg\nPkg.add(\"SHTnsKit\")\n\nFor GPU support, also add:\n\nPkg.add([\"CUDA\", \"KernelAbstractions\"])\n\n","category":"section"},{"location":"quickstart/#Core-Concepts","page":"Quick Start","title":"Core Concepts","text":"","category":"section"},{"location":"quickstart/#Two-Representations-of-Data","page":"Quick Start","title":"Two Representations of Data","text":"Spherical harmonics provide two ways to represent functions on a sphere:\n\nDomain Description Array Shape Best For\nSpatial Values at grid points (nlat, nlon) Visualization, physical intuition\nSpectral Coefficient amplitudes (lmax+1, mmax+1) Analysis, filtering, derivatives\n\nThink of it like audio:\n\nSpatial = the sound wave (amplitude over time)\nSpectral = frequency components (which notes are playing)","category":"section"},{"location":"quickstart/#Key-Parameters","page":"Quick Start","title":"Key Parameters","text":"Parameter Meaning Typical Values\nlmax Maximum spherical harmonic degree 32, 64, 128, 256\nmmax Maximum azimuthal order (usually = lmax) Same as lmax\nnlat Number of latitude points lmax + 2 or more\nnlon Number of longitude points 2*lmax + 1 or more\n\n","category":"section"},{"location":"quickstart/#Your-First-Transform","page":"Quick Start","title":"Your First Transform","text":"using SHTnsKit\n\n# 1. Create configuration\nlmax = 32\ncfg = create_gauss_config(lmax, lmax + 2)\n\n# 2. Create a simple pattern (P_2 Legendre polynomial)\nspatial = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat\n    x = cfg.x[i]  # cos(θ) at this latitude\n    spatial[i, :] .= (3*x^2 - 1) / 2\nend\n\n# 3. Analysis: spatial → spectral\nAlm = analysis(cfg, spatial)\n\n# 4. Synthesis: spectral → spatial\nrecovered = synthesis(cfg, Alm)\n\n# 5. Check accuracy\nerror = maximum(abs.(spatial - recovered))\nprintln(\"Roundtrip error: $error\")  # Should be ~1e-14\n\nOutput:\n\nRoundtrip error: 8.881784197001252e-15\n\n","category":"section"},{"location":"quickstart/#Common-Workflows","page":"Quick Start","title":"Common Workflows","text":"","category":"section"},{"location":"quickstart/#Creating-Test-Fields","page":"Quick Start","title":"Creating Test Fields","text":"cfg = create_gauss_config(64, 66)\n\n# Method 1: From spherical harmonic coefficients\nAlm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nAlm[1, 1] = 1.0    # l=0, m=0: constant (mean value)\nAlm[3, 1] = 0.5    # l=2, m=0: latitude variation\nAlm[3, 3] = 0.3im  # l=2, m=2: longitude variation\nspatial = synthesis(cfg, Alm)\n\n# Method 2: From analytical function\nspatial2 = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat, j in 1:cfg.nlon\n    θ = acos(cfg.x[i])           # Colatitude\n    φ = 2π * (j-1) / cfg.nlon    # Longitude\n    spatial2[i, j] = cos(θ) * sin(2φ)  # Some pattern\nend","category":"section"},{"location":"quickstart/#Spectral-Filtering","page":"Quick Start","title":"Spectral Filtering","text":"cfg = create_gauss_config(64, 66)\nspatial = rand(cfg.nlat, cfg.nlon)\n\n# Transform to spectral space\nAlm = analysis(cfg, spatial)\n\n# Low-pass filter: keep only l ≤ 10\nl_cutoff = 10\nfor l in (l_cutoff+1):cfg.lmax\n    for m in 0:min(l, cfg.mmax)\n        Alm[l+1, m+1] = 0\n    end\nend\n\n# Transform back\nsmoothed = synthesis(cfg, Alm)","category":"section"},{"location":"quickstart/#Computing-Derivatives","page":"Quick Start","title":"Computing Derivatives","text":"cfg = create_gauss_config(32, 34)\n\n# Create test function\nAlm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nAlm[5, 3] = 1.0  # Y_4^2\n\n# Apply Laplacian: Δ Y_l^m = -l(l+1) Y_l^m\nAlm_laplacian = copy(Alm)\nfor l in 0:cfg.lmax\n    for m in 0:min(l, cfg.mmax)\n        Alm_laplacian[l+1, m+1] *= -l * (l + 1)\n    end\nend\n\nlaplacian_field = synthesis(cfg, Alm_laplacian)\n\n","category":"section"},{"location":"quickstart/#GPU-Acceleration","page":"Quick Start","title":"GPU Acceleration","text":"For large problems, use GPU acceleration:\n\nusing SHTnsKit, CUDA\n\n# Check GPU availability\nprintln(\"GPU available: \", CUDA.functional())\n\ncfg = create_gauss_config(128, 130)\nspatial = rand(cfg.nlat, cfg.nlon)\n\n# GPU transforms\nAlm = gpu_analysis(cfg, spatial)\nrecovered = gpu_synthesis(cfg, Alm)\n\n# Safe version (auto-fallback to CPU if GPU fails)\nAlm_safe = gpu_analysis_safe(cfg, spatial)","category":"section"},{"location":"quickstart/#When-to-Use-GPU","page":"Quick Start","title":"When to Use GPU","text":"GPU acceleration is most beneficial for larger problems. As a general guideline:\n\nlmax < 32: CPU is typically faster due to data transfer overhead\nlmax 32-128: GPU becomes beneficial\nlmax > 128: GPU strongly recommended\n\n","category":"section"},{"location":"quickstart/#Vector-Fields","page":"Quick Start","title":"Vector Fields","text":"Decompose vector fields into spheroidal (divergent) and toroidal (rotational) components:\n\ncfg = create_gauss_config(32, 34)\n\n# Create vector field (θ and φ components)\nvθ = rand(cfg.nlat, cfg.nlon)\nvφ = rand(cfg.nlat, cfg.nlon)\n\n# Decompose: spatial → spectral\nSlm, Tlm = spat_to_SHsphtor(cfg, vθ, vφ)\n\n# Reconstruct: spectral → spatial\nvθ_out, vφ_out = SHsphtor_to_spat(cfg, Slm, Tlm)\n\n# Check accuracy\nprintln(\"θ error: \", maximum(abs.(vθ - vθ_out)))\nprintln(\"φ error: \", maximum(abs.(vφ - vφ_out)))","category":"section"},{"location":"quickstart/#Physical-Meaning","page":"Quick Start","title":"Physical Meaning","text":"Component Physical Meaning Examples\nSpheroidal (S) Divergent/compressible flow Pressure gradients, density waves\nToroidal (T) Rotational/incompressible flow Vortices, circulation patterns\n\n","category":"section"},{"location":"quickstart/#Grid-Types","page":"Quick Start","title":"Grid Types","text":"","category":"section"},{"location":"quickstart/#Gauss-Legendre-Grid-(Recommended)","page":"Quick Start","title":"Gauss-Legendre Grid (Recommended)","text":"cfg = create_gauss_config(lmax, nlat)\n\nPoints: Non-uniform spacing (denser near poles)\nAccuracy: Optimal for spectral transforms\nUse for: Most scientific applications","category":"section"},{"location":"quickstart/#Regular-(Equiangular)-Grid","page":"Quick Start","title":"Regular (Equiangular) Grid","text":"cfg = create_regular_config(lmax, nlat)\n\nPoints: Uniform spacing in θ and φ\nAccuracy: Slightly lower than Gauss\nUse for: Visualization, interfacing with GIS data\n\n","category":"section"},{"location":"quickstart/#Performance-Tips","page":"Quick Start","title":"Performance Tips","text":"","category":"section"},{"location":"quickstart/#1.-Preallocate-Arrays","page":"Quick Start","title":"1. Preallocate Arrays","text":"# Allocate once, reuse\nspatial_buffer = zeros(cfg.nlat, cfg.nlon)\nAlm_buffer = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\n\n# Multiple transforms without allocation\nfor i in 1:100\n    fill!(spatial_buffer, 0)\n    # ... fill with data ...\n    Alm_buffer .= analysis(cfg, spatial_buffer)\nend","category":"section"},{"location":"quickstart/#2.-Use-In-Place-Operations","page":"Quick Start","title":"2. Use In-Place Operations","text":"# Out-of-place (allocates new array)\nAlm = analysis(cfg, spatial)\n\n# In-place (writes to existing array)\nanalysis!(cfg, spatial, Alm)","category":"section"},{"location":"quickstart/#3.-Choose-Appropriate-Resolution","page":"Quick Start","title":"3. Choose Appropriate Resolution","text":"Rule of thumb for accuracy:\n\nnlat ≥ lmax + 2 (minimum)\nnlat ≈ 3/2 * lmax (comfortable margin)\nnlon ≥ 2*lmax + 1 (Nyquist for longitude)\n\n","category":"section"},{"location":"quickstart/#Unified-Loop-Abstraction","page":"Quick Start","title":"Unified Loop Abstraction","text":"For custom operations that need to work on both CPU and GPU:\n\nusing SHTnsKit\n\nA = rand(100, 100)\nB = similar(A)\n\n# Works on CPU arrays (uses SIMD)\n@sht_loop B[I] = sin(A[I]) over I ∈ CartesianIndices(A)\n\n# Same code works on GPU arrays (uses CUDA kernels)\nusing CUDA\nA_gpu = CuArray(A)\nB_gpu = similar(A_gpu)\n@sht_loop B_gpu[I] = sin(A_gpu[I]) over I ∈ CartesianIndices(A_gpu)","category":"section"},{"location":"quickstart/#Helper-Functions","page":"Quick Start","title":"Helper Functions","text":"# Iterate over spectral coefficients\nfor idx in spectral_range(lmax, mmax)\n    l, m = idx[1] - 1, idx[2] - 1\n    # ... work with Alm[l+1, m+1] ...\nend\n\n# Iterate over spatial grid\nfor idx in spatial_range(nlat, nlon)\n    i_lat, i_lon = idx[1], idx[2]\n    # ... work with field[i_lat, i_lon] ...\nend\n\n","category":"section"},{"location":"quickstart/#Quick-Reference","page":"Quick Start","title":"Quick Reference","text":"","category":"section"},{"location":"quickstart/#Configuration","page":"Quick Start","title":"Configuration","text":"# Gauss-Legendre grid (recommended)\ncfg = create_gauss_config(lmax, nlat; nlon=nlon, mmax=mmax)\n\n# Regular grid\ncfg = create_regular_config(lmax, nlat; nlon=nlon)","category":"section"},{"location":"quickstart/#Scalar-Transforms","page":"Quick Start","title":"Scalar Transforms","text":"# Forward (spectral → spatial)\nspatial = synthesis(cfg, Alm)\nspatial = synthesis(cfg, Alm; real_output=false)  # Complex output\n\n# Backward (spatial → spectral)\nAlm = analysis(cfg, spatial)","category":"section"},{"location":"quickstart/#Vector-Transforms","page":"Quick Start","title":"Vector Transforms","text":"# Spheroidal-Toroidal decomposition\nSlm, Tlm = spat_to_SHsphtor(cfg, vθ, vφ)\nvθ, vφ = SHsphtor_to_spat(cfg, Slm, Tlm)\n\n# Gradient\ndθ, dφ = SH_to_grad_spat(cfg, Alm)","category":"section"},{"location":"quickstart/#GPU-Transforms","page":"Quick Start","title":"GPU Transforms","text":"Alm = gpu_analysis(cfg, spatial)\nspatial = gpu_synthesis(cfg, Alm)\nAlm = gpu_analysis_safe(cfg, spatial)  # With CPU fallback","category":"section"},{"location":"quickstart/#Operators","page":"Quick Start","title":"Operators","text":"# Laplacian in spectral space: Δf_lm = -l(l+1) f_lm\nfor l in 0:cfg.lmax, m in 0:min(l, cfg.mmax)\n    Alm[l+1, m+1] *= -l * (l + 1)\nend\n\n","category":"section"},{"location":"quickstart/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"GPU Guide: Detailed GPU acceleration documentation\nDistributed Guide: MPI parallelization\nAPI Reference: Complete function documentation\nExamples: Real-world applications\nPerformance Guide: Optimization strategies","category":"section"},{"location":"gpu/#GPU-Acceleration","page":"GPU Acceleration","title":"GPU Acceleration","text":"<div style=\"background: linear-gradient(135deg, #059669 0%, #10b981 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;\">\n    <h2 style=\"margin: 0 0 0.5rem 0; color: white; border: none;\">CUDA-Accelerated Transforms</h2>\n    <p style=\"margin: 0; opacity: 0.9;\">Significant speedup on NVIDIA GPUs with automatic CPU fallback</p>\n</div>\n\nSHTnsKit.jl provides GPU-accelerated spherical harmonic transforms using CUDA and KernelAbstractions.jl for significant performance improvements on NVIDIA GPUs.\n\ntip: When to Use GPU\nGPU acceleration is most beneficial for lmax ≥ 64. For smaller problems, CPU is often faster due to data transfer overhead.\n\n","category":"section"},{"location":"gpu/#Quick-Start","page":"GPU Acceleration","title":"Quick Start","text":"using SHTnsKit, CUDA\n\n# Check GPU availability\nprintln(\"CUDA available: \", CUDA.functional())\nprintln(\"GPU device: \", CUDA.name(CUDA.device()))\n\n# Create configuration\nlmax = 128\ncfg = create_gauss_config(lmax, lmax + 2)\n\n# Create test data\nspatial = rand(cfg.nlat, cfg.nlon)\n\n# GPU-accelerated analysis (spatial → spectral)\nAlm = gpu_analysis(cfg, spatial)\n\n# GPU-accelerated synthesis (spectral → spatial)\nrecovered = gpu_synthesis(cfg, Alm)\n\n# Verify accuracy\nprintln(\"Max error: \", maximum(abs.(spatial - recovered)))\n\n","category":"section"},{"location":"gpu/#Installation","page":"GPU Acceleration","title":"Installation","text":"","category":"section"},{"location":"gpu/#Requirements","page":"GPU Acceleration","title":"Requirements","text":"Julia 1.10+\nNVIDIA GPU with CUDA support\nCUDA toolkit (automatically installed via CUDA.jl)","category":"section"},{"location":"gpu/#Setup","page":"GPU Acceleration","title":"Setup","text":"using Pkg\nPkg.add([\"SHTnsKit\", \"CUDA\", \"GPUArrays\", \"KernelAbstractions\"])\n\n# Verify installation\nusing CUDA\nprintln(\"CUDA version: \", CUDA.version())\nprintln(\"GPU: \", CUDA.name(CUDA.device()))\nprintln(\"Memory: \", CUDA.available_memory() / 1e9, \" GB available\")\n\n","category":"section"},{"location":"gpu/#API-Reference","page":"GPU Acceleration","title":"API Reference","text":"","category":"section"},{"location":"gpu/#Core-Transforms","page":"GPU Acceleration","title":"Core Transforms","text":"","category":"section"},{"location":"gpu/#gpu_analysis","page":"GPU Acceleration","title":"gpu_analysis","text":"gpu_analysis(cfg::SHTConfig, spatial_data; device=get_device(), real_output=true)\n\nGPU-accelerated spherical harmonic analysis transform.\n\nAlgorithm:\n\nTransfer data to GPU\nFFT along longitude (φ) using cuFFT\nLegendre integration along latitude (θ) with parallel kernels\nTransfer coefficients back to CPU\n\nExample:\n\ncfg = create_gauss_config(64, 66)\nspatial = rand(cfg.nlat, cfg.nlon)\n\n# Basic usage\nAlm = gpu_analysis(cfg, spatial)\n\n# Complex output\nAlm_complex = gpu_analysis(cfg, spatial; real_output=false)\n\n# Force CPU fallback\nAlm_cpu = gpu_analysis(cfg, spatial; device=CPU_DEVICE)","category":"section"},{"location":"gpu/#gpu_synthesis","page":"GPU Acceleration","title":"gpu_synthesis","text":"gpu_synthesis(cfg::SHTConfig, coeffs; device=get_device(), real_output=true)\n\nGPU-accelerated spherical harmonic synthesis transform.\n\nAlgorithm:\n\nTransfer coefficients to GPU\nLegendre summation with parallel kernels\nInverse FFT along longitude using cuFFT\nTransfer spatial field back to CPU\n\nExample:\n\ncfg = create_gauss_config(64, 66)\nAlm = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nAlm[3, 1] = 1.0  # Y_2^0 mode\n\n# Synthesis\nspatial = gpu_synthesis(cfg, Alm)\n\n# Complex output (no Hermitian symmetry enforcement)\nspatial_complex = gpu_synthesis(cfg, Alm; real_output=false)","category":"section"},{"location":"gpu/#Memory-Safe-Variants","page":"GPU Acceleration","title":"Memory-Safe Variants","text":"","category":"section"},{"location":"gpu/#gpu_analysis_safe-/-gpu_synthesis_safe","page":"GPU Acceleration","title":"gpu_analysis_safe / gpu_synthesis_safe","text":"gpu_analysis_safe(cfg::SHTConfig, spatial_data; device=get_device(), real_output=true)\ngpu_synthesis_safe(cfg::SHTConfig, coeffs; device=get_device(), real_output=true)\n\nMemory-safe versions that automatically fall back to CPU if:\n\nInsufficient GPU memory\nGPU encounters an error\nCUDA is not available\n\nExample:\n\n# Safe for large problems - automatically falls back to CPU if needed\nAlm = gpu_analysis_safe(cfg, large_spatial_data)","category":"section"},{"location":"gpu/#Vector-Field-Transforms","page":"GPU Acceleration","title":"Vector Field Transforms","text":"","category":"section"},{"location":"gpu/#gpu_spat_to_SHsphtor","page":"GPU Acceleration","title":"gpu_spat_to_SHsphtor","text":"gpu_spat_to_SHsphtor(cfg::SHTConfig, vθ, vφ; device=get_device())\n\nGPU-accelerated spheroidal-toroidal decomposition.\n\nExample:\n\ncfg = create_gauss_config(32, 34)\n\n# Create vector field components\nvθ = rand(cfg.nlat, cfg.nlon)\nvφ = rand(cfg.nlat, cfg.nlon)\n\n# Decompose into spheroidal and toroidal\nSlm, Tlm = gpu_spat_to_SHsphtor(cfg, vθ, vφ)","category":"section"},{"location":"gpu/#gpu_SHsphtor_to_spat","page":"GPU Acceleration","title":"gpu_SHsphtor_to_spat","text":"gpu_SHsphtor_to_spat(cfg::SHTConfig, Slm, Tlm; device=get_device(), real_output=true)\n\nGPU-accelerated vector field synthesis.\n\nExample:\n\n# Reconstruct vector field from coefficients\nvθ_out, vφ_out = gpu_SHsphtor_to_spat(cfg, Slm, Tlm)","category":"section"},{"location":"gpu/#Spectral-Operators","page":"GPU Acceleration","title":"Spectral Operators","text":"","category":"section"},{"location":"gpu/#gpu_apply_laplacian!","page":"GPU Acceleration","title":"gpu_apply_laplacian!","text":"gpu_apply_laplacian!(cfg::SHTConfig, coeffs; device=get_device())\n\nApply the spherical Laplacian operator in spectral space: Δf_lm = -l(l+1) f_lm\n\nExample:\n\nAlm = rand(ComplexF64, cfg.lmax+1, cfg.mmax+1)\ngpu_apply_laplacian!(cfg, Alm)  # Modifies Alm in-place\n\n","category":"section"},{"location":"gpu/#Device-Management","page":"GPU Acceleration","title":"Device Management","text":"","category":"section"},{"location":"gpu/#Checking-Device-Status","page":"GPU Acceleration","title":"Checking Device Status","text":"using SHTnsKit, CUDA\n\n# Get current device\ndevice = get_device()\nprintln(\"Current device: \", device)  # CUDA_DEVICE or CPU_DEVICE\n\n# Available GPUs\ngpus = get_available_gpus()\nfor gpu in gpus\n    println(\"GPU $(gpu.id): $(gpu.name)\")\nend","category":"section"},{"location":"gpu/#Selecting-GPU","page":"GPU Acceleration","title":"Selecting GPU","text":"# Set active GPU by ID\nset_gpu_device(0)  # First GPU\nset_gpu_device(1)  # Second GPU (if available)\n\n# Force CPU execution\nAlm = gpu_analysis(cfg, spatial; device=CPU_DEVICE)","category":"section"},{"location":"gpu/#Memory-Management","page":"GPU Acceleration","title":"Memory Management","text":"# Check GPU memory\ninfo = gpu_memory_info()\nprintln(\"Free memory: \", info.free / 1e9, \" GB\")\nprintln(\"Total memory: \", info.total / 1e9, \" GB\")\n\n# Estimate memory for operation\nbytes_needed = estimate_memory_usage(cfg, :analysis)\nprintln(\"Memory needed: \", bytes_needed / 1e6, \" MB\")\n\n# Check if operation will fit\nif check_gpu_memory(bytes_needed)\n    Alm = gpu_analysis(cfg, spatial)\nelse\n    println(\"Using CPU fallback\")\n    Alm = analysis(cfg, spatial)\nend\n\n# Clear GPU cache\ngpu_clear_cache!()\n\n","category":"section"},{"location":"gpu/#Multi-GPU-Support","page":"GPU Acceleration","title":"Multi-GPU Support","text":"For large problems, distribute work across multiple GPUs.","category":"section"},{"location":"gpu/#Setup-2","page":"GPU Acceleration","title":"Setup","text":"using SHTnsKit, CUDA\n\n# Create multi-GPU configuration\nmgpu = create_multi_gpu_config(128, 130;\n    strategy=:latitude,      # Split by latitude bands\n    gpu_ids=[0, 1]           # Use GPUs 0 and 1\n)\n\nprintln(\"Using $(length(mgpu.gpu_devices)) GPUs\")","category":"section"},{"location":"gpu/#Transforms","page":"GPU Acceleration","title":"Transforms","text":"# Multi-GPU analysis\nspatial = rand(130, 257)\nAlm = multi_gpu_analysis(mgpu, spatial)\n\n# Multi-GPU synthesis\nrecovered = multi_gpu_synthesis(mgpu, Alm)","category":"section"},{"location":"gpu/#Memory-Streaming","page":"GPU Acceleration","title":"Memory Streaming","text":"For problems larger than GPU memory:\n\n# Automatic chunking based on available memory\nAlm = multi_gpu_analysis_streaming(mgpu, huge_spatial_data;\n    max_memory_per_gpu = 4 * 1024^3  # 4 GB per GPU\n)\n\n# Estimate chunks needed\nn_chunks = estimate_streaming_chunks(mgpu, size(huge_spatial_data))\nprintln(\"Will use $n_chunks chunks per GPU\")\n\n","category":"section"},{"location":"gpu/#Unified-Loop-Abstraction","page":"GPU Acceleration","title":"Unified Loop Abstraction","text":"The @sht_loop macro provides unified CPU/GPU execution:\n\nusing SHTnsKit\n\n# Works on both CPU and GPU arrays\nA = rand(100, 100)        # CPU array\nB = similar(A)\n\n@sht_loop B[I] = A[I] * 2.0 over I ∈ CartesianIndices(A)\n\n# Same code works on GPU\nusing CUDA\nA_gpu = CuArray(A)\nB_gpu = similar(A_gpu)\n\n@sht_loop B_gpu[I] = A_gpu[I] * 2.0 over I ∈ CartesianIndices(A_gpu)","category":"section"},{"location":"gpu/#Backend-Control","page":"GPU Acceleration","title":"Backend Control","text":"# Check current backend mode\nprintln(loop_backend())  # \"auto\" (default)\n\n# Force CPU SIMD (useful for debugging)\nset_loop_backend(\"SIMD\")\n\n# Restore auto-detection\nset_loop_backend(\"auto\")\n\n","category":"section"},{"location":"gpu/#Performance-Tips","page":"GPU Acceleration","title":"Performance Tips","text":"","category":"section"},{"location":"gpu/#1.-Batch-Operations","page":"GPU Acceleration","title":"1. Batch Operations","text":"Minimize data transfers by batching operations:\n\n# Inefficient: many small transfers\nfor field in fields\n    Alm = gpu_analysis(cfg, field)\n    # ... process ...\nend\n\n# Efficient: keep data on GPU\ngpu_data = CuArray(stack(fields))\n# Process all at once on GPU","category":"section"},{"location":"gpu/#2.-Use-Appropriate-Resolution","page":"GPU Acceleration","title":"2. Use Appropriate Resolution","text":"GPU overhead is significant for small problems. As a general guideline:\n\nlmax < 32: CPU is typically faster due to data transfer overhead\nlmax 32-128: GPU becomes beneficial\nlmax > 128: GPU strongly recommended","category":"section"},{"location":"gpu/#3.-Preallocate-GPU-Buffers","page":"GPU Acceleration","title":"3. Preallocate GPU Buffers","text":"For repeated transforms:\n\n# Create cuFFT plans once\nplan = create_cufft_plan(cfg.nlat, cfg.nlon)\n\n# Reuse buffer\nbuffer = CUDA.zeros(ComplexF64, cfg.nlat, cfg.nlon)\ncopyto!(buffer, data)\n\n# Use preplanned FFT\ngpu_fft!(plan, buffer)","category":"section"},{"location":"gpu/#4.-Monitor-Memory","page":"GPU Acceleration","title":"4. Monitor Memory","text":"# Profile memory usage\nCUDA.@time begin\n    Alm = gpu_analysis(cfg, spatial)\nend\n\n# Check for memory leaks\nfor i in 1:100\n    gpu_analysis(cfg, spatial)\n    if i % 10 == 0\n        info = gpu_memory_info()\n        println(\"Iteration $i: $(info.free / 1e9) GB free\")\n    end\nend\n\n","category":"section"},{"location":"gpu/#Troubleshooting","page":"GPU Acceleration","title":"Troubleshooting","text":"","category":"section"},{"location":"gpu/#Common-Issues","page":"GPU Acceleration","title":"Common Issues","text":"","category":"section"},{"location":"gpu/#\"CUDA-not-available\"","page":"GPU Acceleration","title":"\"CUDA not available\"","text":"# Check CUDA installation\nusing CUDA\nprintln(CUDA.functional())  # Should be true\nprintln(CUDA.version())     # Should show version\n\n# If false, reinstall CUDA.jl\nusing Pkg\nPkg.rm(\"CUDA\")\nPkg.add(\"CUDA\")\nPkg.build(\"CUDA\")","category":"section"},{"location":"gpu/#\"Out-of-GPU-memory\"","page":"GPU Acceleration","title":"\"Out of GPU memory\"","text":"# Use safe variants\nAlm = gpu_analysis_safe(cfg, spatial)\n\n# Or reduce problem size\ncfg_small = create_gauss_config(64, 66)  # Instead of 256\n\n# Or use streaming\nAlm = multi_gpu_analysis_streaming(mgpu, spatial; max_memory_per_gpu=2*1024^3)","category":"section"},{"location":"gpu/#\"Numerical-differences-from-CPU\"","page":"GPU Acceleration","title":"\"Numerical differences from CPU\"","text":"GPU floating-point operations may have small differences due to:\n\nDifferent reduction order (non-associativity)\nFMA (fused multiply-add) usage\n\nTypical differences are ~1e-14 for Float64, which is acceptable for most applications.\n\n","category":"section"},{"location":"gpu/#Example:-Complete-Workflow","page":"GPU Acceleration","title":"Example: Complete Workflow","text":"using SHTnsKit, CUDA\n\n# Setup\nprintln(\"=== GPU Spherical Harmonic Transform ===\")\nprintln(\"GPU: \", CUDA.name(CUDA.device()))\nprintln(\"Memory: \", CUDA.available_memory() / 1e9, \" GB\")\n\n# Configuration\nlmax = 128\ncfg = create_gauss_config(lmax, lmax + 2)\nprintln(\"Grid: $(cfg.nlat) × $(cfg.nlon)\")\n\n# Create test field: Y_4^2 + Y_6^0\nAlm_true = zeros(ComplexF64, cfg.lmax+1, cfg.mmax+1)\nAlm_true[5, 3] = 1.0 + 0.5im  # Y_4^2\nAlm_true[7, 1] = 0.8          # Y_6^0\n\n# Synthesis on GPU\nspatial = gpu_synthesis(cfg, Alm_true)\nprintln(\"Spatial field: min=$(minimum(real(spatial))), max=$(maximum(real(spatial)))\")\n\n# Analysis on GPU\nAlm_recovered = gpu_analysis(cfg, real.(spatial))\n\n# Verify\nerror = maximum(abs.(Alm_true - Alm_recovered))\nprintln(\"Roundtrip error: $error\")\n\n# Benchmark\nusing BenchmarkTools\nprintln(\"\\nBenchmarks:\")\n@btime gpu_analysis($cfg, $spatial)\n@btime gpu_synthesis($cfg, $Alm_true)\n\nprintln(\"Done!\")\n\n","category":"section"},{"location":"gpu/#See-Also","page":"GPU Acceleration","title":"See Also","text":"Performance Guide - General optimization tips\nDistributed Computing - MPI parallelization\nAPI Reference - Complete function documentation","category":"section"},{"location":"#SHTnsKit.jl","page":"Home","title":"SHTnsKit.jl","text":"<div style=\"background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%); color: white; padding: 2.5rem; border-radius: 16px; margin-bottom: 2rem; text-align: center;\">\n    <h1 style=\"font-size: 2.5rem; margin: 0 0 0.5rem 0; color: white; border: none;\">SHTnsKit.jl</h1>\n    <p style=\"font-size: 1.25rem; margin: 0; opacity: 0.95;\">High-Performance Spherical Harmonic Transforms for Julia</p>\n    <p style=\"margin-top: 1rem; font-size: 0.9rem; opacity: 0.8;\">CPU | GPU | MPI Distributed | Auto-Differentiation</p>\n</div>\n\n(Image: Build Status) (Image: Documentation) (Image: License: GPL v3)\n\n","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin: 2rem 0;\">\n\n<div style=\"background: white; border: 1px solid #e2e8f0; border-radius: 12px; padding: 1.5rem; transition: transform 0.2s, box-shadow 0.2s;\">\n    <h3 style=\"color: #2563eb; margin-top: 0;\">Core Transforms</h3>\n    <ul style=\"margin: 0; padding-left: 1.25rem; color: #475569;\">\n        <li>Forward & backward spherical harmonic transforms</li>\n        <li>Scalar, vector, and complex field support</li>\n        <li>In-place operations for memory efficiency</li>\n    </ul>\n</div>\n\n<div style=\"background: white; border: 1px solid #e2e8f0; border-radius: 12px; padding: 1.5rem;\">\n    <h3 style=\"color: #7c3aed; margin-top: 0;\">GPU Acceleration</h3>\n    <ul style=\"margin: 0; padding-left: 1.25rem; color: #475569;\">\n        <li>CUDA/cuFFT for NVIDIA GPUs</li>\n        <li>KernelAbstractions.jl backend</li>\n        <li>Automatic CPU fallback</li>\n    </ul>\n</div>\n\n<div style=\"background: white; border: 1px solid #e2e8f0; border-radius: 12px; padding: 1.5rem;\">\n    <h3 style=\"color: #059669; margin-top: 0;\">MPI Distributed</h3>\n    <ul style=\"margin: 0; padding-left: 1.25rem; color: #475569;\">\n        <li>PencilArrays domain decomposition</li>\n        <li>Scalable to thousands of cores</li>\n        <li>Efficient communication patterns</li>\n    </ul>\n</div>\n\n<div style=\"background: white; border: 1px solid #e2e8f0; border-radius: 12px; padding: 1.5rem;\">\n    <h3 style=\"color: #dc2626; margin-top: 0;\">Analysis Tools</h3>\n    <ul style=\"margin: 0; padding-left: 1.25rem; color: #475569;\">\n        <li>Power spectrum analysis</li>\n        <li>Energy diagnostics</li>\n        <li>Wigner D-matrix rotations</li>\n    </ul>\n</div>\n\n</div>\n\n","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\n\n# Basic installation\nPkg.add(\"SHTnsKit\")\n\n# With GPU support\nPkg.add([\"SHTnsKit\", \"CUDA\", \"KernelAbstractions\"])\n\n# With MPI support\nPkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\"])","category":"section"},{"location":"#Hello-World","page":"Home","title":"Hello World","text":"using SHTnsKit\n\n# Create configuration for lmax=16\ncfg = create_gauss_config(16, 18)\n\n# Create a test pattern on the sphere\nspatial = zeros(cfg.nlat, cfg.nlon)\nfor i in 1:cfg.nlat\n    x = cfg.x[i]  # cos(θ)\n    spatial[i, :] .= (3*x^2 - 1)/2  # Y_2^0 pattern\nend\n\n# Transform: spatial → spectral → spatial\nAlm = analysis(cfg, spatial)\nrecovered = synthesis(cfg, Alm)\n\n# Verify roundtrip accuracy\nprintln(\"Error: \", maximum(abs.(spatial - recovered)))  # ~1e-14\n\ntip: Pro Tip\nFor large problems (lmax > 64), use GPU acceleration with gpu_analysis() and gpu_synthesis() for significant speedup.\n\n","category":"section"},{"location":"#GPU-Example","page":"Home","title":"GPU Example","text":"using SHTnsKit, CUDA\n\ncfg = create_gauss_config(128, 130)\nspatial = rand(cfg.nlat, cfg.nlon)\n\n# GPU-accelerated transforms\nAlm = gpu_analysis(cfg, spatial)\nrecovered = gpu_synthesis(cfg, Alm)\n\n# Safe version with automatic CPU fallback\nAlm_safe = gpu_analysis_safe(cfg, spatial)\n\n","category":"section"},{"location":"#Scientific-Applications","page":"Home","title":"Scientific Applications","text":"<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 1rem; margin: 1.5rem 0;\">\n\n<div style=\"background: #eff6ff; border-radius: 8px; padding: 1rem; border-left: 4px solid #2563eb;\">\n    <strong style=\"color: #1e40af;\">Climate Science</strong>\n    <p style=\"margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #475569;\">\n        Atmospheric dynamics, weather prediction, ocean circulation\n    </p>\n</div>\n\n<div style=\"background: #fef3c7; border-radius: 8px; padding: 1rem; border-left: 4px solid #f59e0b;\">\n    <strong style=\"color: #92400e;\">Geophysics</strong>\n    <p style=\"margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #475569;\">\n        Gravitational fields, magnetic anomalies, Earth surface modeling\n    </p>\n</div>\n\n<div style=\"background: #f3e8ff; border-radius: 8px; padding: 1rem; border-left: 4px solid #7c3aed;\">\n    <strong style=\"color: #5b21b6;\">Astrophysics</strong>\n    <p style=\"margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #475569;\">\n        CMB analysis, stellar dynamics, gravitational waves\n    </p>\n</div>\n\n<div style=\"background: #ecfdf5; border-radius: 8px; padding: 1rem; border-left: 4px solid #10b981;\">\n    <strong style=\"color: #065f46;\">Fluid Dynamics</strong>\n    <p style=\"margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #475569;\">\n        Vorticity-divergence decomposition, turbulence on spheres\n    </p>\n</div>\n\n</div>\n\n","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0;\">\n\n<a href=\"quickstart/\" style=\"display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: white; border: 1px solid #e2e8f0; border-radius: 8px; text-decoration: none; color: #1e293b; transition: all 0.2s;\">\n    <div>\n        <strong>Quick Start</strong>\n        <p style=\"margin: 0; font-size: 0.85rem; color: #64748b;\">Get started in minutes</p>\n    </div>\n</a>\n\n<a href=\"gpu/\" style=\"display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: white; border: 1px solid #e2e8f0; border-radius: 8px; text-decoration: none; color: #1e293b; transition: all 0.2s;\">\n    <div>\n        <strong>GPU Guide</strong>\n        <p style=\"margin: 0; font-size: 0.85rem; color: #64748b;\">CUDA acceleration</p>\n    </div>\n</a>\n\n<a href=\"distributed/\" style=\"display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: white; border: 1px solid #e2e8f0; border-radius: 8px; text-decoration: none; color: #1e293b; transition: all 0.2s;\">\n    <div>\n        <strong>Distributed</strong>\n        <p style=\"margin: 0; font-size: 0.85rem; color: #64748b;\">MPI parallelization</p>\n    </div>\n</a>\n\n<a href=\"api/\" style=\"display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: white; border: 1px solid #e2e8f0; border-radius: 8px; text-decoration: none; color: #1e293b; transition: all 0.2s;\">\n    <div>\n        <strong>API Reference</strong>\n        <p style=\"margin: 0; font-size: 0.85rem; color: #64748b;\">Complete documentation</p>\n    </div>\n</a>\n\n</div>\n\nPages = [\n    \"quickstart.md\",\n    \"gpu.md\",\n    \"distributed.md\",\n    \"api/index.md\",\n    \"examples/index.md\",\n    \"performance.md\",\n    \"advanced.md\"\n]\nDepth = 1\n\n","category":"section"},{"location":"#Installation-Options","page":"Home","title":"Installation Options","text":"Setup Command Use Case\nBasic Pkg.add(\"SHTnsKit\") Single CPU, getting started\nGPU + CUDA, KernelAbstractions NVIDIA GPU acceleration\nMPI + MPI, PencilArrays, PencilFFTs Cluster computing\nFull All of the above Maximum flexibility\n\nnote: Requirements\nJulia 1.10 or later\nFor GPU: NVIDIA GPU with CUDA support\nFor MPI: OpenMPI or MPICH installed\n\n","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"We welcome contributions! See our GitHub repository for:\n\nBug reports and feature requests\nDocumentation improvements\nPull requests\n\n","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use SHTnsKit.jl in your research, please cite:\n\n@software{shtnskit,\n  author = {Kar, Subhajit},\n  title = {SHTnsKit.jl: High-Performance Spherical Harmonic Transforms},\n  url = {https://github.com/subhk/SHTnsKit.jl},\n  year = {2024}\n}\n\n","category":"section"},{"location":"#License","page":"Home","title":"License","text":"SHTnsKit.jl is released under the GNU General Public License v3.0.\n\n<div style=\"text-align: center; margin-top: 2rem; padding: 1.5rem; background: #f8fafc; border-radius: 8px;\">\n    <p style=\"margin: 0; color: #64748b;\">\n        Made for the scientific computing community\n    </p>\n</div>","category":"section"}]
}
